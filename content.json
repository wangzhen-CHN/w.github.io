{"pages":[{"title":"一像素","text":"产生原因由于分辨率 DPI 的差异，高清手机屏上的 1px 实际上是由 2×2 个像素点来渲染，有的屏幕甚至用到了 3×3 个像素点所以 border: 1px 在移动端会渲染为 2px 的边框解决方案一 (不推荐) 使用高度为 1px 的图片代替 1234.border-bottom-1px { border-width: 0 0 1px 0; border-image: url(1px.png) 0 0 2 0 stretch;} 解决方案二通过 js 获取到设备像素比，然后动态添加 标签 ，控制缩放 123456789101112(function() { var scale = 1.0; if (window.devicePixelRatio === 2) { scale *= 0.5; } if (window.devicePixelRatio === 3) { scale *= 0.333333; } var text = ''; document.write(text); })(); 解决方案三 (推荐)使用伪类 :after 创建 1px 的边框，后通过 媒体查询（media） 适配不同的设备像素比 123456789101112131415161718192021222324252627282930313233.border-bottom-1px { position: relative;}.border-bottom-1px::after { content: ' '; position: absolute; left: 0; bottom: 0; width: 100%; height: 1px; background-color: #222;}/* 1.5倍屏 */@media only screen and (-webkit-min-device-pixel-ratio: 1.5) { .border-bottom::after { -webkit-transform: scaleY(0.7); transform: scaleY(0.7); }}/* 2倍屏 */@media only screen and (-webkit-min-device-pixel-ratio: 2) { .border-bottom::after { -webkit-transform: scaleY(0.5); transform: scaleY(0.5); }}/* 3倍屏 */@media only screen and (-webkit-min-device-pixel-ratio: 3) { .border-bottom::after { -webkit-transform: scaleY(0.33); transform: scaleY(0.33); }}","link":"/%E5%8E%9F%E5%A7%8BMD/01.%E4%B8%80%E5%83%8F%E7%B4%A0.html"},{"title":"vue.js中$watch的oldvalue与newValue","text":"由于vue内部机制，导致对象或数组改变时旧值将与新值相同vue.js文档中指出 详情>> 解决方案一，this.$set 方法二，Object.assign()方法三，计算属性 computed1234567export default { data () { return { msg: 'Highlighted!' } }}","link":"/%E5%8E%9F%E5%A7%8BMD/04.vue.$watch%E5%80%BC%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98.html"},{"title":"axios","text":"axios 1234567891011121314axios({ method: 'post', url: 'xxxxxx', data: { a: 'data1', b: 'data2' }}) .then(function(response) { console.log(response) //请求成功 }) .catch(function(error) { console.log(error) //请求失败 }) 执行 GET 请求12345678910111213// 为给定 ID 的 user 创建请求axios .get('/user', { params: { ID: 12345 } }) .then(function(response) { console.log(response) }) .catch(function(error) { console.log(error) }) 1234567891011### 执行 POST 请求axios.post('/user', { ID: '1234'}).then(function (response) { console.log(response);}).catch(function (error) { console.log(error);});","link":"/%E5%8E%9F%E5%A7%8BMD/03.axios.html"},{"title":"关于SPA,SEO,SSR","text":"前后端分离开发的大趋势下催生几个概念：SPA、SEO和SSR SPA(single page web application 单页Web应用)SPA是一种 网络应用程序(WebApp)模型。在传统的网站中，不同的页面之间的切换都是直接从服务器加载一整个新的页面，而在SPA这个模型中，是通过动态地重写页面的部分与用户交互，而避免了过多的数据交换，响应速度自然相对更高 特点 速度：更好的用户体验，让用户在web app感受native app的速度和流畅， MVVM：经典MVVM开发模式，前后端各负其责。 ajax：重前端，业务逻辑全部在本地操作，数据都需要通过AJAX同步、提交。 路由：在URL中采用#号来作为当前视图的地址,改变#号后的参数，页面并不会重载 目前常见的几个SPA框架 AngularJS React Vue.js SPA的优点 基本上前面所说的前后端分离的优点它都有，另外还有以下的一些优点 页面之间的切换非常快 一定程度上减少了后端服务器的压力（不用管页面逻辑和渲染） 后端程序只需要提供API，完全不用管客户端到底是Web界面还是手机等 SPA的缺点 首屏打开速度很慢，因为用户首次加载需要先下载SPA框架及应用程序的代码，然后再渲染页面。 不利于SEO SEO（Search Engine Optimization 搜索引擎优化）SEO是一种通过了解搜索引擎的运作规则（如何抓取网站页面，如何索引以及如何根据特定的关键字展现搜索结果排序等）来调整网站，以提高该网站在搜索引擎中某些关键词的搜索结果排名。 搜索引擎工作原理在搜索引擎网站，比如百度，在其后台有一个非常庞大的数据库，里面存储了海量的关键词，而每个关键词又对应着很多网址，这些网址是百度程序从茫茫的互联网上一点一点下载收集而来的，这些程序称之为“搜索引擎蜘蛛”或“网络爬虫”。这些勤劳的“蜘蛛”每天在互联网上爬行，从一个链接到另一个链接，下载其中的内容，进行分析提炼，找到其中的关键词，如果“蜘蛛”认为关键词在数据库中没有而对用户是有用的便存入数据库。反之，如果“蜘蛛”认为是垃圾信息或重复信息，就舍弃不要，继续爬行，寻找最新的、有用的信息保存起来提供用户搜索。当用户搜索时，就能检索出与关键字相关的网址显示给访客。 一个关键词对用多个网址，因此就出现了排序的问题，相应的当与关键词最吻合的网址就会排在前面了。在“蜘蛛”抓取网页内容，提炼关键词的这个过程中，就存在一个问题：“蜘蛛”能否看懂。如果网站内容是flash和js，那么它是看不懂的，会犯迷糊，即使关键字再贴切也没用。相应的，如果网站内容是它的语言，那么它便能看懂，它的语言即SEO。 1 1 矛盾点在当前前端趋势下，SPA一般只有一个主页面，内容由js获取，不便于搜索引擎获取 SPA应用中，通常通过AJAX获取数据，而这里就难以保证我们的页面能被搜索引擎正常收录到。并且有一些搜索引擎不支持执行JS和通过AJAX获取数据，那就更不用提SEO了 SSR (Server-Side Rendering 服务器端渲染）在普通的SPA中，一般是将框架及网站页面代码发送到浏览器，然后在浏览器中生成和操作DOM（这里也是第一次访问SPA网站在同等带宽及网络延迟下比传统的在后端生成HTML发送到浏览器要更慢的主要原因），但其实也可以将SPA应用打包到服务器上，在服务器上渲染出HTML，发送到浏览器，这样的HTML页面还不具备交互能力，所以还需要与SPA框架配合，在浏览器上“混合”成可交互的应用程序。所以，只要能合理地运用SSR技术，不仅能一定程度上解决首屏慢的问题，还能获得更好的SEO SSR的优点 更快的响应时间，不用等待所有的JS都下载完成，浏览器便能显示比较完整的页面了。 更好的SSR，我们可以将SEO的关键信息直接在后台就渲染成HTML，而保证搜索引擎的爬虫都能爬取到关键数据。 SSR的缺点 相对于仅仅需要提供静态文件的服务器，SSR中使用的渲染程序自然会占用更多的CPU和内存资源 一些常用的浏览器API可能无法正常使用，比如window、docment和alert等，如果使用的话需要对运行的环境加以判断 开发调试会有一些麻烦，因为涉及了浏览器及服务器，对于SPA的一些组件的生命周期的管理会变得复杂 可能会由于某些因素导致服务器端渲染的结果与浏览器端的结果不一致。 SSR常用框架 React 的 Next Vue.js 的 Nuxt 参考 浅谈SPA、SEO、SSR 百度百科","link":"/%E5%8E%9F%E5%A7%8BMD/02.%E5%85%B3%E4%BA%8ESPA,SEO,SSR.html"},{"title":"MarkDown教程","text":"Markdown 是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown 兼容html语言 基础语法一、标题123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 二、字体1234**这是加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~ 这是加粗的文字这是倾斜的文字这是斜体加粗的文字这是加删除线的文字 三、引用1> 引用的内容 这段文字是引用的内容… 四、分割线1234-------******** ***，— 三个以上，效果相同 五、超链接，图片123超链接: [文字](url)图片:[文字](url)图片超链接: ![[百度 https://www.baidu.com](https://www.baidu.com)](https://img-bss.csdn.net/201901101629501036.png) 超链接示例百度 https://www.baidu.com 图片示例 六、列表1. 无序列表1234- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 列表内容 列表内容 列表内容 2. 有序列表12341. 列表内容2. 列表内容3. 列表内容25. 列表内容 列表内容 列表内容 列表内容 列表内容 七. 表格1234表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容 表头 表头 表头 表头 表头 表头 内容 内容 内容 内容 内容 内容 内容 内容 内容 内容 内容 内容 八. 代码高亮1单行代码 `代码内容` 单行代码 console.log('') 1234567891011getUserInfo () { this.Post({ url: this.apiNames['获取用户信息'], data: {}, success: (data) => { if (data.responseStatus.resultCode === 0) { this.userInfo = data.userInfo } } })}","link":"/%E5%8E%9F%E5%A7%8BMD/06.MarkDown%E6%95%99%E7%A8%8B.html"},{"title":"rem使用","text":"项目中使用rem需要引入自动换算js 比例100：1 100px=1rem12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//自定义设计稿的宽度：designWidth//最大宽度:maxWidth//这段js的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为750，最大宽度为750，则为(750,750);(function(designWidth, maxWidth) { var doc = document, win = window, docEl = doc.documentElement, remStyle = document.createElement(\"style\"), tid; function refreshRem() { var width = docEl.getBoundingClientRect().width; maxWidth = maxWidth || 540; width>maxWidth && (width=maxWidth); var rem = width * 100 / designWidth; remStyle.innerHTML = 'html{font-size:' + rem + 'px;}'; } if (docEl.firstElementChild) { docEl.firstElementChild.appendChild(remStyle); } else { var wrap = doc.createElement(\"div\"); wrap.appendChild(remStyle); doc.write(wrap.innerHTML); wrap = null; } //要等 wiewport 设置好后才能执行 refreshRem，不然 refreshRem 会执行2次； refreshRem(); win.addEventListener(\"resize\", function() { clearTimeout(tid); //防止执行两次 tid = setTimeout(refreshRem, 300); }, false); win.addEventListener(\"pageshow\", function(e) { if (e.persisted) { // 浏览器后退的时候重新计算 clearTimeout(tid); tid = setTimeout(refreshRem, 300); } }, false); if (doc.readyState === \"complete\") { doc.body.style.fontSize = \"16px\"; } else { doc.addEventListener(\"DOMContentLoaded\", function(e) { doc.body.style.fontSize = \"16px\"; }, false); }})(750, 750);","link":"/%E5%8E%9F%E5%A7%8BMD/07.rem%E4%BD%BF%E7%94%A8.html"},{"title":"前端面试","text":"面试准备及技巧一. 面试前简历及面试准备假如你要面试一个公司，他们主招 Vue 技术栈的前端开发，那么你的简历里面只有 Vue 这个名词是不够的，最好能体现出 Vue 的生态来。这样写就不错：熟练使用 ElementUI＋Vue＋Vuex 开发项目，Webpack 构建项目，Nuxtjs 做服务端渲染。 简历中出现的技术一定要能说出个一二三，不要一问三不知 简历堆砌技术名词其实是一把双刃剑： 不写技术名词，简历容易被刷掉； 写上的话，可是需要充分的准备哦，否则这可能成为你的软肋； 写进简历的项目一定要了如指掌 项目的前期构建， 总结项目开发中遇到的问题及解决思路 在项目中学到的经验 项目的打包上线部署 二. 面试 落落大方，面试是公司选你，也是你选公司的过程。工作可以不要，气势不能丢 准备一段自我介绍 几句个人简介，名字毕业学校，工作经验，上家公司 主要负责的工作 换工作的原因及预期 具备常用算法，数组操作，经典css布局等的手写能力 对前端技术实现原理，底层，优缺点的理解 既然你熟练使用VUE 那vue有什么优缺点 职业规划 你有什么问题想问我？ 三. 面试总结 面试千篇一律，善于总结方能立于不败之地","link":"/%E5%8E%9F%E5%A7%8BMD/08.%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95.html"},{"title":"浮生六记","text":"衡量爱情的标准，从来只有一个 贾平凹说过：人，可以无知，但不可以无趣。 一本《浮生六记》让我认识了一位有趣的文人——沈复： 他，才情出众，既有文人风雅，亦有稚童心态，虽半生潦倒，依然和夫人将清贫的生活过得热气腾腾。 地上两只虫子打架，沈复聚精会神地看了半天，还琢磨人家为什么打架，难道有奸情？一只癞蛤蟆跳了过来，长舌一卷，把虫子吞进了肚子。看得入迷的沈复，被吓了一跳。等回过神，气得咬牙切齿：“好你个癞蛤蟆，坏了我看虫的雅兴！”逮到蛤蟆胖揍了一番，撵出院子，方才泄愤。 夏日里到处飞的蚊子，在他的凝视下，都幻化成端庄的白鹤，在空中翩翩起舞，他扬起一抹迷之微笑，突然灵光一闪: 没有白云，白鹤飞个什么劲？赶紧把蚊子轰到蚊帐里，搞点烟雾，蚊帐里顿时“仙气”缭绕。顾不上自己被熏得眼泪汪汪，看着蚊子冲破烟雾飞翔，他心满意足地大笑起来：“这才是白鹤飞在青云上啊！”所谓有趣——是对细小事物的全神贯注是天马行空的狂想是奋不顾身的热爱。 01有趣的人，一粥一菜都是温存沈复爱吃蒜，芸娘不吃。 日子久了，芸娘被沈复的蒜味“熏陶”得受不了，也跟着吃蒜。 如此一来，两人耳鬓厮磨时，就不会嫌弃彼此浓郁的口气了。 芸娘爱吃腐乳酱瓜，便让沈复也尝尝。 奈何腐乳闻着臭气烘烘，沈复将吃腐乳比作“狗吃屎”，芸娘气坏了： “我跟着你吃臭大蒜，你却不陪我吃腐乳，还骂我是狗。” 架不住娇妻的投诉，沈复硬着头皮“当了一回狗”。 入口后，腐乳独特的咸鲜香辣，让他如释重负，原来闻着臭的东西，吃起来的味道妙不可言。 从此，大蒜、腐乳成了二人餐桌上的美食。 芸娘的堂姐出嫁，沈复去观礼。 忙到大半夜，他饿得眼冒金星，到处找吃的。 芸娘神秘地对沈复招手，将他带到自己的闺房，变戏法一般从柜子里端出了一锅清粥，一碟小菜。 沈复两眼放光，激动坏了，就差给芸娘跪了高呼“万岁”。 当时，两人尚未成亲， 一个大男人躲在大姑娘的房里吃东西，还是低调点好。 沈复压住狂喜，挽起袖子食指大动，芸娘的脸上飞起一抹红云，笑颜如花。 沈复一生清贫，清粥咸菜是家常便饭，只要和心上人一起吃，粗茶淡饭亦可饕餮。 一粥一菜里都是温存。 02有趣的人，花草虫石，处处美好沈复爱好花草，放在现代，他就是“花痴”。 菊花盛放时，他会剪下来做插花。 每个花瓶只插一个品种，一种颜色，单数花枝。 经沈复之手完成的插花作品，或亭亭玉立，或飞舞横斜，姿态万千，错落有致。 在他卧室的床头，常年有一瓶雅致的插花，都是他的作品。 家里的锅碗瓢盆，也是沈复搞艺术创作的素材。 沈复对虫子是真爱。他的艺术作品怎能少了虫子的身影？ 他和芸娘去抓螳螂和蝴蝶，用细丝把它们栓起来绑在花草上，还不忘给虫子凹造型： 蝴蝶的翅膀要展开一点才有韵味，螳螂的双臂要高举才威武。 经沈复的用心打造，花草虫石，完美地组合在一起，精致且富有活力，让人赞不绝口。 一花一草，一石一虫，都是大自然的馈赠。 有人熟视无睹，有人视若珍宝。 有趣的人，总能懂得花草虫石，都是生活的美好。 03有趣的人，嬉笑玩闹，不拘世俗有一次，水仙庙要举行庆典。 因插花水平一流，朋友邀请沈复布置插花。 沈复想让芸娘同去，就在她跟前鼓吹： “这场夜宴，花色明艳，光影流离，吹奏笙箫，欢歌唱闹，好玩得很！” 芸娘心动，出于旧俗，顾虑女人不便去，沈复狡黠一笑： “戴我的冠，穿我的衣，化女为男，我们一起去！” 他把芸娘的发髻散开，改为辫子，将他的帽子戴在妻子头上，长衫略长不要紧，从腰间打折缝起来，外头再套个马褂，就看不出来了。 沈复又给妻子买了时髦的“蝴蝶靴”，男女都可以穿。 芸娘担心婆婆知道了会生气，沈复拍着胸脯担保： “怕什么？老太太走亲戚去了，我俩悄悄走，悄悄回，他们怎么知道？再说了，庙里管事的都是我朋友，就算识破你是女人家，还不是一笑了之？” 芸娘这才欣然前往。 有趣的人，洒脱不羁，不为世俗所阻。 芸娘守旧礼，对待丈夫十分恭敬。 沈复不在乎那么多规矩，他就喜欢拉着妻子的手，咬个耳朵，说点情话，温情地给妻子整理衣袖。 每次这么做，芸娘都拘谨地说“岂敢”，沈复逗趣她“礼多必诈”。 两口子路上遇见了，沈复就拱手作揖，说声“得罪”，芸娘心神领会，屈膝回礼来句“岂敢”。 两句敬辞，被夫妻二人玩成了口头禅。 有趣的人，之乎者也、繁文缛节也是一种雅兴和情怀。 04有趣的人，以诗下酒，印章传情红袖添香，诗酒相伴，是文人墨客的标配，沈复也不例外。 他看书写字时，芸娘就研磨沏茶。 他好喝两口小酒，芸娘虽不善饮酒，但放开怀也能喝上几杯。 为了让妻子陪自己小酌，沈复教她行酒令“射覆”，类似现代的摇骰子猜数字，两人玩得不亦乐乎，谁输了谁喝酒，以诗下酒，好不快活。 沈复还喜欢和妻子“讨论学术”，他鼓励且欣赏妻子有自己的见解和评判。 两人曾讨论过，谁才是唐诗界的扛把子。 沈复选了沉稳的杜甫，芸娘则喜欢活泼的李白。 沈复吃醋地调侃说： “想不到，我的老婆竟然是李太白的拥趸”，芸娘笑着安抚他：“你字称三白，也带个‘白’字。我的诗歌启蒙来源于白居易，再加上李太白，你们这三白，都是我崇敬的人。” 才子佳人，精神相交便不过如此了。 沈复工作不稳定，偶尔去外地给人当幕僚，夫妻两地分居的日子里，鸿雁传书就是他和芸娘互诉衷肠的方式。 沈复亲手打造了朱白两枚印章，章面写着“愿生生世世为夫妇”，他拿的是阳文，妻子拿的是阴文。 写完信，拿出印章，呵一口气，用力地盖在信笺上，整颗心也跟着印了上去。 印章都是情侣款，这种境界的秀恩爱，也是前无古人后无来者了。 有趣的人，诗词可下酒，印章能传情，生活处处有情调。 05有趣，是做人的最高配置林语堂将《浮生六记》视为知己并评价说： “读沈复的书，使我感到这安乐的奥妙，远超乎尘俗之压迫与人身之痛苦。” 很多人喜欢沈复，是被《浮生六记》中的烟火江南，闺房趣事所吸引。 他笔下妙趣横生、温情款款的片段，让大家都不由地感慨： 浮生若梦，做人还是有趣的好。 《沉默的大多数》中有句话： 我活在世上，无非想明白些道理，遇见些有趣的事。 有趣的人，才能遇见有趣的事。 感谢沈复教会我们，做个有趣之人，桃花树下，酒烫茶温；布衣菜饭，可乐终身。 不论生活贫穷还是富裕，顺境还是逆境，用心生活，把平凡无奇的日子过成精彩纷呈的段子。","link":"/%E5%8E%9F%E5%A7%8BMD/09.%E6%B5%AE%E7%94%9F%E5%85%AD%E8%AE%B0.html"},{"title":"ESlint报错解决方案","text":"Unary operator ‘++’ usedESLint 不允许++ 运算比如1234567891011for (let i = 0; i < 3; i ++) { // ...}for (let i = 0; i < 3; i += 1) { // ...}temp++var temp = 0;temp += 1; Missing radix parameter 缺少基数参数ESLint parseInt()方法必须传入第二参数radix1234parseInt(string, radix)parseInt('123', 0)radix 取值范围2~36代表数字基数不传或传0代表10进制–传入0可解决parseInt(‘123’, 0) Unexpected string concatenation 意外的字符串连接不允许字符串拼接1'0' + month ======》`0${month}`; Expected to return a value in arrow function 箭头函数期望有返回值使用map时Eslint希望有返回值123columns.map(item => { item.name='xx'});1：用Object.keys(this.props.ntn).forEach去替换.map，因为ESLint array-callback-return这个警告是因为在使用map, filter , reduce 没有去返回一个值。 2：当然也可以使用map,在react中用jsx的方式，直接把{}改成()即可。 扩展map:和forEach非常相似，都是用来遍历数组中的每一项值的，用来遍历数组中的每一项；区别：map的回调函数中支持return返回值；return的是啥，相当于把数组中的这一项变为啥（并不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了）；不管是forEach还是map 都支持第二个参数值，第二个参数的意思是把匿名回调函数中的this进行修改。 JSX props should not use .bind() JSX语法中不能使用.bind() ERROR 1 SUCCESS Option 1: Use arrow functions (with babel-plugins) PS:- Experimental feature 1234567891011121314class MyComponent extends Component { handleClick = (args) => () => { // access args here; // handle the click event } render() { return ( ..... ) }}Option 2: Not recommended Define arrow functions in render 123456789101112class MyComponent extends Component { render() { const handleClick = () => { // handle the click event } return ( ..... ) } } Option 3: Use binding in constructor 12345678910111213141516171819class MyComponent extends Component { constructor() { super(); this.handleClick = this.handleClick.bind(this); } handleClick() { // handle click } render() { return ( ..... ) } }","link":"/%E5%8E%9F%E5%A7%8BMD/10.ESlint%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"},{"title":"VUE开发中遇到的问题","text":"对象数组深度监听 问题: 后端传过来的数组是一个数组对象，页面中绑定对象中某一具体的属性，当该值变化时调用某个函数，自然想到就是watch方法。但如何watch数组对象中某一个具体的属性，显然不可能一个个属性写watch。 解决办法： watch整个对象，设置deep为true，当该对象发生改变时，调用处理函数。 将页面中绑定的属性写在computed函数中，watch这个computed中的函数，当对象值改变时会进入computed函数中，进而进入watch函数中，再调用处理函数。 子组件生命周期执行顺序问题 组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。 组件的销毁操作是先父后子，销毁完成的顺序是先子后父。 加载渲染过程父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount- >子mounted->父mounted 子组件更新过程父beforeUpdate->子beforeUpdate->子updated->父updated 父组件更新过程父 beforeUpdate -> 父 updated 销毁过程父beforeDestroy->子beforeDestroy->子destroyed->父destroyed 本地开发跨域问题 问题: 在本地开发请求后端服务器接口的时候，都不可避免的会遇到跨域的问题。 解决方法可以通过加一个node中间层或者nginx做反向代理。 如果是用vue-cli搭建的项目，vue-cli在config中自带了一个proxyTable属性，可以配置这个属性解决跨域的问题。 父组件控制子组件样式问题使用 xx /deep/ xx 或者 xx >>> xx 对象赋值无法双向绑定例如对象obj ={a:1},如果想要修改obj中的a属性，通过obj.a = 2这样赋值，页面不会更新，需使用vue.set方法更改才会起作用， Vue.set(this,obj,a,2); 同样，如果要给obj增加一个新属性，如果该属性未在data中声明，页面也不会刷新。也就是vue文档中声明的“Vue 不能检测到对象属性的添加或删除”，同样需要使用vue.set方法进行赋值才好使。 Vue事件总线（eventBus）$on()会多次触发解决办法 问题:注册的总线事件（Bus）,页面没有强制刷新，存在组件切换，bus.$on方法会被多次绑定，造成触发一次但多个响应的情况 解决办法就是在利用$on 接收事件的组件的beforeDestroy或destroy周期中将事件进行销毁，使用$off()123beforeDestroy () { bus.$off('BUS_NAME')}附上github上Vue作者尤大大关于这问题的解答：https://github.com/vuejs/vue/issues/3399","link":"/%E5%8E%9F%E5%A7%8BMD/VUE%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html"},{"title":"JavaScript进阶问题列表","text":"JavaScript 进阶问题列表 摘自github 从基础到进阶，测试你有多了解 JavaScript，刷新你的知识，或者帮助你的 coding 面试！ 答案在问题下方的折叠部分，点击即可展开问题。祝你好运 1. 输出是什么？12345678function sayHi() { console.log(name) console.log(age) var name = 'Lydia' let age = 21}sayHi() A: Lydia 和 undefined B: Lydia 和 ReferenceError C: ReferenceError 和 21 D: undefined 和 ReferenceError 答案#### 答案: D在函数内部，我们首先通过 var 关键字声明了 name 变量。这意味着变量被提升了（内存空间在创建阶段就被设置好了），直到程序运行到定义变量位置之前默认值都是 undefined。因为当我们打印 name 变量时还没有执行到定义变量的位置，因此变量的值保持为 undefined。通过 let 和 const 关键字声明的变量也会提升，但是和 var 不同，它们不会被初始化。在我们声明（初始化）之前是不能访问它们的。这个行为被称之为暂时性死区。当我们试图在声明之前访问它们时，JavaScript 将会抛出一个 ReferenceError 错误。 2. 输出是什么？1234567for (var i = 0; i < 3; i++) { setTimeout(() => console.log(i), 1)}for (let i = 0; i < 3; i++) { setTimeout(() => console.log(i), 1)} A: 0 1 2 和 0 1 2 B: 0 1 2 和 3 3 3 C: 3 3 3 和 0 1 2 答案#### 答案: C由于 JavaScript 的事件循环，setTimeout 回调会在遍历结束后才执行。因为在第一个遍历中遍历 i 是通过 var 关键字声明的，所以这个值是全局作用域下的。在遍历过程中，我们通过一元操作符 ++ 来每次递增 i 的值。当 setTimeout 回调执行的时候，i 的值等于 3。在第二个遍历中，遍历 i 是通过 let 关键字声明的：通过 let 和 const 关键字声明的变量是拥有块级作用域（指的是任何在 {} 中的内容）。在每次的遍历过程中，i 都有一个新值，并且每个值都在循环内的作用域中。 3. 输出是什么？12345678910const shape = { radius: 10, diameter() { return this.radius * 2 }, perimeter: () => 2 * Math.PI * this.radius}shape.diameter()shape.perimeter() A: 20 and 62.83185307179586 B: 20 and NaN C: 20 and 63 D: NaN and 63 答案#### 答案: B注意 diameter 的值是一个常规函数，但是 perimeter 的值是一个箭头函数。对于箭头函数，this 关键字指向的是它当前周围作用域（简单来说是包含箭头函数的常规函数，如果没有常规函数的话就是全局对象），这个行为和常规函数不同。这意味着当我们调用 perimeter 时，this 不是指向 shape 对象，而是它的周围作用域（在例子中是 window）。在 window 中没有 radius 这个属性，因此返回 undefined。 4. 输出是什么？12;+true!'Lydia' A: 1 and false B: false and NaN C: false and false 答案#### 答案: A一元操作符加号尝试将 bool 转为 number。true 转换为 number 的话为 1，false 为 0。字符串 'Lydia' 是一个真值，真值取反那么就返回 false。 5. 哪一个是无效的？12345678const bird = { size: 'small'}const mouse = { name: 'Mickey', small: true} A: mouse.bird.size B: mouse[bird.size] C: mouse[bird[\"size\"]] D: All of them are valid 答案#### 答案: A在 JavaScript 中，所有对象的 keys 都是字符串（除非对象是 Symbol）。尽管我们可能不会定义它们为字符串，但它们在底层总会被转换为字符串。当我们使用括号语法时（[]），JavaScript 会解释（或者 unboxes）语句。它首先看到第一个开始括号 [ 并继续前进直到找到结束括号 ]。只有这样，它才会计算语句的值。mouse[bird.size]：首先计算 bird.size，这会得到 small。mouse[\"small\"] 返回 true。然后使用点语法的话，上面这一切都不会发生。mouse 没有 bird 这个 key，这也就意味着 mouse.bird 是 undefined。然后当我们使用点语法 mouse.bird.size 时，因为 mouse.bird 是 undefined，这也就变成了 undefined.size。这个行为是无效的，并且会抛出一个错误类似 Cannot read property \"size\" of undefined。 6. 输出是什么？123456let c = { greeting: 'Hey!' }let dd = cc.greeting = 'Hello'console.log(d.greeting) A: Hello B: undefined C: ReferenceError D: TypeError 答案#### 答案: A在 JavaScript 中，当设置两个对象彼此相等时，它们会通过引用进行交互。首先，变量 c 的值是一个对象。接下来，我们给 d 分配了一个和 c 对象相同的引用。因此当我们改变其中一个对象时，其实是改变了所有的对象。 7. 输出是什么？1234567let a = 3let b = new Number(3)let c = 3console.log(a == b)console.log(a === b)console.log(b === c) A: true false true B: false false true C: true false false D: false true true 答案#### 答案: Cnew Number() 是一个内建的函数构造器。虽然它看着像是一个 number，但它实际上并不是一个真实的 number：它有一堆额外的功能并且它是一个对象。当我们使用 == 操作符时，它只会检查两者是否拥有相同的值。因为它们的值都是 3，因此返回 true。然后，当我们使用 === 操作符时，两者的值以及类型都应该是相同的。new Number() 是一个对象而不是 number，因此返回 false。 8. 输出是什么？12345678910111213class Chameleon { static colorChange(newColor) { this.newColor = newColor return this.newColor } constructor({ newColor = 'green' } = {}) { this.newColor = newColor }}const freddie = new Chameleon({ newColor: 'purple' })freddie.colorChange('orange') A: orange B: purple C: green D: TypeError 答案#### 答案: DcolorChange 是一个静态方法。静态方法被设计为只能被创建它们的构造器使用（也就是 Chameleon），并且不能传递给实例。因为 freddie 是一个实例，静态方法不能被实例使用，因此抛出了 TypeError 错误。 9. 输出是什么？123let greetinggreetign = {} // Typo!console.log(greetign) A: {} B: ReferenceError: greetign is not defined C: undefined 答案#### 答案: A代码打印出了一个对象，这是因为我们在全局对象上创建了一个空对象！当我们将 greeting 写错成 greetign 时，JS 解释器实际在上浏览器中将它视为 global.greetign = {} （或者 window.greetign = {}）。为了避免这个为题，我们可以使用 `”use strict”。这能确保当你声明变量时必须赋值。 10. 当我们这么做时，会发生什么？12345function bark() { console.log('Woof!')}bark.animal = 'dog' A: Nothing, this is totally fine! B: SyntaxError. You cannot add properties to a function this way. C: undefined D: ReferenceError 答案#### 答案: A这在 JavaScript 中是可以的，因为函数是对象！（除了基本类型之外其他都是对象）函数是一个特殊的对象。你写的这个代码其实不是一个实际的函数。函数是一个拥有属性的对象，并且属性也可被调用。 11. 输出是什么？1234567891011function Person(firstName, lastName) { this.firstName = firstName; this.lastName = lastName;}const member = new Person(\"Lydia\", \"Hallie\");Person.getFullName = function () { return `${this.firstName} ${this.lastName}`;}console.log(member.getFullName()); A: TypeError B: SyntaxError C: Lydia Hallie D: undefined undefined 答案#### 答案: A你不能像常规对象那样，给构造函数添加属性。如果你想一次性给所有实例添加特性，你应该使用原型。因此本例中，使用如下方式：123Person.prototype.getFullName = function () { return `${this.firstName} ${this.lastName}`;}这才会使 member.getFullName() 起作用。为什么这么做有益的？假设我们将这个方法添加到构造函数本身里。也许不是每个 Person 实例都需要这个方法。这将浪费大量内存空间，因为它们仍然具有该属性，这将占用每个实例的内存空间。相反，如果我们只将它添加到原型中，那么它只存在于内存中的一个位置，但是所有实例都可以访问它！ 12. 输出是什么？12345678910function Person(firstName, lastName) { this.firstName = firstName this.lastName = lastName}const lydia = new Person('Lydia', 'Hallie')const sarah = Person('Sarah', 'Smith')console.log(lydia)console.log(sarah) A: Person {firstName: \"Lydia\", lastName: \"Hallie\"} and undefined B: Person {firstName: \"Lydia\", lastName: \"Hallie\"} and Person {firstName: \"Sarah\", lastName: \"Smith\"} C: Person {firstName: \"Lydia\", lastName: \"Hallie\"} and {} D:Person {firstName: \"Lydia\", lastName: \"Hallie\"} and ReferenceError 答案#### 答案: A对于 sarah，我们没有使用 new 关键字。当使用 new 时，this 引用我们创建的空对象。当未使用 new 时，this 引用的是全局对象（global object）。我们说 this.firstName 等于 \"Sarah\"，并且 this.lastName 等于 \"Smith\"。实际上我们做的是，定义了 global.firstName = 'Sarah' 和 global.lastName = 'Smith'。而 sarah 本身是 undefined。 13. 事件传播的三个阶段是什么？ A: Target > Capturing > Bubbling B: Bubbling > Target > Capturing C: Target > Bubbling > Capturing D: Capturing > Target > Bubbling 答案#### 答案: D在捕获（capturing）阶段中，事件从祖先元素向下传播到目标元素。当事件达到目标（target）元素后，冒泡（bubbling）才开始。 14. 所有对象都有原型。 A: true B: false 答案#### 答案: B除了基本对象（base object），所有对象都有原型。基本对象可以访问一些方法和属性，比如 .tostring。这就是为什么你可以使用内置的 JavaScript 方法！所有这些方法在原型上都是可用的。虽然 JavaScript 不能直接在对象上找到这些方法，但 JavaScript 会沿着原型链找到它们，以便于你使用。 15. 输出是什么？12345function sum(a, b) { return a + b}sum(1, '2') A: NaN B: TypeError C: \"12\" D: 3 答案#### 答案: CJavaScript 是一种动态类型语言：我们不指定某些变量的类型。值可以在你不知道的情况下自动转换成另一种类型，这种类型称为隐式类型转换（implicit type coercion）。Coercion 是指将一种类型转换为另一种类型。在本例中，JavaScript 将数字 1 转换为字符串，以便函数有意义并返回一个值。在数字类型（1）和字符串类型（'2'）相加时，该数字被视为字符串。我们可以连接字符串，比如 \"Hello\" + \"World\"，这里发生的是 \"1\" + \"2\"，它返回 \"12\"。 16. 输出是什么？1234let number = 0console.log(number++)console.log(++number)console.log(number) A: 1 1 2 B: 1 2 2 C: 0 2 2 D: 0 1 2 答案#### 答案: C一元后自增运算符 ++：1. 返回值（返回 0）2. 值自增（number 现在是 1）一元前自增运算符 ++：1. 值自增（number 现在是 2）2. 返回值（返回 2）结果是 0 2 2. 17. 输出是什么？12345678910function getPersonInfo(one, two, three) { console.log(one) console.log(two) console.log(three)}const person = 'Lydia'const age = 21getPersonInfo`${person} is ${age} years old` A: \"Lydia\" 21 [\"\", \" is \", \" years old\"] B: [\"\", \" is \", \" years old\"] \"Lydia\" 21 C: \"Lydia\" [\"\", \" is \", \" years old\"] 21 答案#### 答案: B如果使用标记模板字面量，第一个参数的值总是包含字符串的数组。其余的参数获取的是传递的表达式的值！ 18. 输出是什么？1234567891011function checkAge(data) { if (data === { age: 18 }) { console.log('You are an adult!') } else if (data == { age: 18 }) { console.log('You are still an adult.') } else { console.log(`Hmm.. You don't have an age I guess`) }}checkAge({ age: 18 }) A: You are an adult! B: You are still an adult. C: Hmm.. You don't have an age I guess 答案#### 答案: C在测试相等性时，基本类型通过它们的值（value）进行比较，而对象通过它们的引用（reference）进行比较。JavaScript 检查对象是否具有对内存中相同位置的引用。题目中我们正在比较的两个对象不是同一个引用：作为参数传递的对象引用的内存位置，与用于判断相等的对象所引用的内存位置并不同。这也是 { age: 18 } === { age: 18 } 和 { age: 18 } == { age: 18 } 都返回 false 的原因。 19. 输出是什么？12345function getAge(...args) { console.log(typeof args)}getAge(21) A: \"number\" B: \"array\" C: \"object\" D: \"NaN\" 答案#### 答案: C扩展运算符（...args）会返回实参组成的数组。而数组是对象，因此 typeof args 返回 \"object\"。 20. 输出是什么？1234567function getAge() { 'use strict' age = 21 console.log(age)}getAge() A: 21 B: undefined C: ReferenceError D: TypeError 答案#### 答案: C使用 \"use strict\"，你可以确保不会意外地声明全局变量。我们从来没有声明变量 age，因为我们使用 \"use strict\"，它将抛出一个引用错误。如果我们不使用 \"use strict\"，它就会工作，因为属性 age 会被添加到全局对象中了。 21. 输出是什么？1const sum = eval('10*10+5') A: 105 B: \"105\" C: TypeError D: \"10*10+5\" 答案#### 答案: A代码以字符串形式传递进来，eval 对其求值。如果它是一个表达式，就像本例中那样，它对表达式求值。表达式是 10 * 10 + 5。这将返回数字 105。 22. cool_secret 可访问多长时间？1sessionStorage.setItem('cool_secret', 123) A: Forever, the data doesn’t get lost. B: When the user closes the tab. C: When the user closes the entire browser, not only the tab. D: When the user shuts off their computer. 答案#### 答案: B关闭 tab 标签页 后，sessionStorage 存储的数据才会删除。如果使用 localStorage，那么数据将永远在那里，除非调用了 localStorage.clear()。 23. 输出是什么？1234var num = 8var num = 10console.log(num) A: 8 B: 10 C: SyntaxError D: ReferenceError 答案#### 答案: B使用 var 关键字，你可以用相同的名称声明多个变量。然后变量将保存最新的值。你不能使用 let 或 const 来实现这一点，因为它们是块作用域的。 24. 输出是什么？1234567const obj = { 1: 'a', 2: 'b', 3: 'c' }const set = new Set([1, 2, 3, 4, 5])obj.hasOwnProperty('1')obj.hasOwnProperty(1)set.has('1')set.has(1) A: false true false true B: false true true true C: true true false true D: true true true true 答案#### 答案: C所有对象的键（不包括 Symbol）在底层都是字符串，即使你自己没有将其作为字符串输入。这就是为什么 obj.hasOwnProperty('1') 也返回 true。对于集合，它不是这样工作的。在我们的集合中没有 '1'：set.has('1') 返回 false。它有数字类型为 1，set.has(1) 返回 true。 25. 输出是什么？12const obj = { a: 'one', b: 'two', a: 'three' }console.log(obj) A: { a: \"one\", b: \"two\" } B: { b: \"two\", a: \"three\" } C: { a: \"three\", b: \"two\" } D: SyntaxError 答案#### 答案: C如果你有两个名称相同的键，则键会被替换掉。它仍然位于第一个键出现的位置，但是值是最后出现那个键的值。 26. JavaScript 全局执行上下文为你做了两件事：全局对象和 this 关键字。 A: true B: false C: it depends 答案#### 答案: A基本执行上下文是全局执行上下文：它是代码中随处可访问的内容。 27. 输出是什么？1234for (let i = 1; i < 5; i++) { if (i === 3) continue console.log(i)} A: 1 2 B: 1 2 3 C: 1 2 4 D: 1 3 4 答案#### 答案: C如果某个条件返回 true，则 continue 语句跳过本次迭代。 28. 输出是什么？1234567String.prototype.giveLydiaPizza = () => { return 'Just give Lydia pizza already!'}const name = 'Lydia'name.giveLydiaPizza() A: \"Just give Lydia pizza already!\" B: TypeError: not a function C: SyntaxError D: undefined 答案#### 答案: AString 是内置的构造函数，我们可以向它添加属性。我只是在它的原型中添加了一个方法。基本类型字符串被自动转换为字符串对象，由字符串原型函数生成。因此，所有 string(string 对象)都可以访问该方法！ 29. 输出是什么？12345678const a = {}const b = { key: 'b' }const c = { key: 'c' }a[b] = 123a[c] = 456console.log(a[b]) A: 123 B: 456 C: undefined D: ReferenceError 答案#### 答案: B对象的键被自动转换为字符串。我们试图将一个对象 b 设置为对象 a 的键，且相应的值为 123。然而，当字符串化一个对象时，它会变成 \"[Object object]\"。因此这里说的是，a[\"Object object\"] = 123。然后，我们再一次做了同样的事情，c 是另外一个对象，这里也有隐式字符串化，于是，a[\"Object object\"] = 456。然后，我们打印 a[b]，也就是 a[\"Object object\"]。之前刚设置为 456，因此返回的是 456。 30. 输出是什么？1234567const foo = () => console.log('First')const bar = () => setTimeout(() => console.log('Second'))const baz = () => console.log('Third')bar()foo()baz() A: First Second Third B: First Third Second C: Second First Third D: Second Third First 答案#### 答案: B我们有一个 setTimeout 函数，并首先调用它。然而，它是最后打印日志的。这是因为在浏览器中，我们不仅有运行时引擎，还有一个叫做 WebAPI 的东西。WebAPI 提供了 setTimeout 函数，也包含其他的，例如 DOM。将 callback 推送到 WebAPI 后，setTimeout 函数本身(但不是回调！)将从栈中弹出。现在，foo 被调用，打印 \"First\"。foo 从栈中弹出，baz 被调用. 打印 \"Third\"。WebAPI 不能随时向栈内添加内容。相反，它将回调函数推到名为 queue 的地方。这就是事件循环开始工作的地方。一个事件循环查看栈和任务队列。如果栈是空的，它接受队列上的第一个元素并将其推入栈。bar 被调用，打印 \"Second\"，然后它被栈弹出。 31. 当点击按钮时，event.target是什么？1234567 Click! A: Outer div B: Inner div C: button D: An array of all nested elements. 答案#### 答案: C导致事件的最深嵌套的元素是事件的 target。你可以通过 event.stopPropagation 来停止冒泡。 32. 当您单击该段落时，日志输出是什么？12345 Click here! A: p div B: div p C: p D: div 答案#### 答案: A如果我们点击 p，我们会看到两个日志：p 和 div。在事件传播期间，有三个阶段：捕获、目标和冒泡。默认情况下，事件处理程序在冒泡阶段执行（除非将 useCapture 设置为 true）。它从嵌套最深的元素向外传播。 33. 输出是什么？12345678const person = { name: 'Lydia' }function sayHi(age) { console.log(`${this.name} is ${age}`)}sayHi.call(person, 21)sayHi.bind(person, 21) A: undefined is 21 Lydia is 21 B: function function C: Lydia is 21 Lydia is 21 D: Lydia is 21 function 答案#### 答案: D使用这两种方法，我们都可以传递我们希望 this 关键字引用的对象。但是，.call 是立即执行的。.bind 返回函数的副本，但带有绑定上下文！它不是立即执行的。 34. 输出是什么？12345function sayHi() { return (() => 0)()}typeof sayHi() A: \"object\" B: \"number\" C: \"function\" D: \"undefined\" 答案#### 答案: BsayHi 方法返回的是立即执行函数(IIFE)的返回值.此立即执行函数的返回值是 0， 类型是 number参考：只有7种内置类型：null，undefined，boolean，number，string，object 和 symbol。 function 不是一种类型，函数是对象，它的类型是object。 35. 下面哪些值是 falsy?1234560new Number(0);('');(' ')new Boolean(false)undefined A: 0, '', undefined B: 0, new Number(0), '', new Boolean(false), undefined C: 0, '', new Boolean(false), undefined D: All of them are falsy 答案#### 答案: A只有 6 种 falsy 值:- undefined- null- NaN- 0- '' (empty string)- falseFunction 构造函数, 比如 new Number 和 new Boolean，是 truthy。 36. 输出是什么？1console.log(typeof typeof 1) A: \"number\" B: \"string\" C: \"object\" D: \"undefined\" 答案#### 答案: Btypeof 1 返回 \"number\"。typeof \"number\" 返回 \"string\"。 37. 输出是什么？123const numbers = [1, 2, 3]numbers[10] = 11console.log(numbers) A: [1, 2, 3, 7 x null, 11] B: [1, 2, 3, 11] C: [1, 2, 3, 7 x empty, 11] D: SyntaxError 答案#### 答案: C当你为数组设置超过数组长度的值的时候， JavaScript 会创建名为 “empty slots” 的东西。它们的值实际上是 undefined。你会看到以下场景：[1, 2, 3, 7 x empty, 11]这取决于你的运行环境（每个浏览器，以及 node 环境，都有可能不同） 38. 输出是什么？1234567891011;(() => { let x, y try { throw new Error() } catch (x) { ;(x = 1), (y = 2) console.log(x) } console.log(x) console.log(y)})() A: 1 undefined 2 B: undefined undefined undefined C: 1 1 2 D: 1 undefined undefined 答案#### 答案: Acatch 代码块接收参数 x。当我们传递参数时，这与之前定义的变量 x 不同 。这个 x 是属于 catch 块级作用域的。然后，我们将块级作用域中的变量赋值为 1，同时也设置了变量 y 的值。现在，我们打印块级作用域中的变量 x，值为 1。catch 块之外的变量 x 的值仍为 undefined， y 的值为 2。当我们在 catch 块之外执行 console.log(x) 时，返回 undefined，y 返回 2。 39. JavaScript 中的一切都是？ A: primitive or object B: function or object C: trick question! only objects D: number or object-答案 答案: AJavaScript 只有基本类型和对象。 基本类型包括 boolean, null, undefined, bigint, number, string, symbol。 40. 输出是什么？123456;[[0, 1], [2, 3]].reduce( (acc, cur) => { return acc.concat(cur) }, [1, 2]) A: [0, 1, 2, 3, 1, 2] B: [6, 1, 2] C: [1, 2, 0, 1, 2, 3] D: [1, 2, 6] 答案#### 答案: C[1, 2]是初始值。初始值将会作为首次调用时第一个参数 acc 的值。在第一次执行时， acc 的值是 [1, 2]， cur 的值是 [0, 1]。合并它们，结果为 [1, 2, 0, 1]。第二次执行， acc 的值是 [1, 2, 0, 1]， cur 的值是 [2, 3]。合并它们，最终结果为 [1, 2, 0, 1, 2, 3] 41. 输出是什么？123!!null!!''!!1 A: false true false B: false false true C: false true true D: true true false 答案#### 答案: Bnull 是 falsy。 !null 的值是 true。 !true 的值是 false。\"\" 是 falsy。 !\"\" 的值是 true。 !true 的值是 false。1 是 truthy。 !1 的值是 false。 !false 的值是 true。 42. setInterval 方法的返回值是什么？1setInterval(() => console.log('Hi'), 1000) A: a unique id B: the amount of milliseconds specified C: the passed function D: undefined 答案#### 答案: AsetInterval 返回一个唯一的 id。此 id 可被用于 clearInterval 函数来取消定时。 43. 输出是什么？1;[...'Lydia'] A: [\"L\", \"y\", \"d\", \"i\", \"a\"] B: [\"Lydia\"] C: [[], \"Lydia\"] D: [[\"L\", \"y\", \"d\", \"i\", \"a\"]] 答案#### 答案: Astring 类型是可迭代的。扩展运算符将迭代的每个字符映射成一个元素。","link":"/%E5%8E%9F%E5%A7%8BMD/11.JavaScript%E8%BF%9B%E9%98%B6%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8.html"},{"title":"VUE知识点梳理","text":"1.对于MVVM的理解 MVVM 是 Model-View-ViewModel 的缩写 Model : 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为 View : 用户操作界面。当ViewModel对Model进行更新的时候，会通过数据绑定更新到View ViewModel ： 业务逻辑层，View需要什么数据，ViewModel要提供这个数据；View有某些操作，ViewModel就要响应这些操作，所以可以说它是Model for View.总结： MVVM模式简化了界面与业务的依赖，解决了数据频繁更新MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。 MVVM的缺点1.Bug很难被调试: 因为使用双向绑定的模式，当你看到界面异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。2.一个大的模块中model也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就造成了花费更多的内存3.对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高 2.VUE生命周期 beforeCreate （创建前）vue实例的挂载元素$el和数据对象 data都是undefined, 还未初始化 created (创建后) 完成了 data数据初始化, el还未初始化 beforeMount (载入前) vue实例的$el和data都初始化了, 相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。 mounted (载入后) 在el 被新创建的 vm.$el替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互 beforeUpdate (更新前) 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。 updated （更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 beforeDestroy (销毁前） 在实例销毁之前调用。实例仍然完全可用。 destroyed (销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 3.Vue实现数据双向绑定的原理 vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调 缺陷 Object.defineProperty 无法监听数组变化，通过劫持push()pop() shift() unshift() splice() sort() reverse() Object.defineProperty 只能劫持对象的属性,因此需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历 Proxy可以直接监听数组的变化 Proxy可以直接监听对象而非属性 4.vue-router 路由守卫 全局守卫 router.beforeEach 全局前置守卫 进入路由之前 router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用 router.afterEach 全局后置钩子 进入路由之后 路由独享守卫 路由定义是设置 123456789101112const router = new VueRouter({ routes: [ { path: '/foo', component: Foo, beforeEnter: (to, from, next) => { // 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖 // ... } } ] }) 路由组件内的守卫 beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 this，组件实例还没被创建 beforeRouteUpdate (2.2) 路由复用同一个组件时, 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 this beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this Vue的路由实现：hash模式 和 history模式 hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取； 特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。 hash 模式下，仅 hash 符号之前的内容会被包含在请求中，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。 history模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。 history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。 后端如果缺少对 /items/id 的路由处理，将返回 404 错误。 Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源： 如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。 组件之间的传值通信 1. 父组件给子组件传值 使用props，父组件可以使用props向子组件传递数据 1234567891011// parent// childexport default { props: { msg: { type: String, required: true } }} 2. 子组件向父组件通信123456789101112131415161718// 父组件vue模板 import child from './child.vue';export default { components: { child }, methods: { func (msg) { console.log(msg); } }} 123456789101112131415161718192021// 子组件vue模板 点我export default { props: { msg: { type: String, required: true } }, methods () { handleClick () { //........ this.$emit('msgFunc'); } }} 3. 非父子, 兄弟组件之间通信 使用Bus 或 vuex VUEX Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。有 5 种，分别是 state、getter、mutation、action、modulevuex 的 store 是什么？vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 datastate 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性vuex 的 getter 是什么？getter 可以对 state 进行计算操作，它就是 store 的计算属性虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用如果一个状态只在一个组件内使用，是可以不用 gettersvuex 的 mutation 是什么？更改Vuex的store中的状态的唯一方法是提交mutationvuex 的 action 是什么？action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态action 可以包含任意异步操作vue 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 action 中vuex 的 module 是什么？面对复杂的应用程序，当管理的状态比较多时；我们需要将vuex的store对象分割成模块(modules)。 父子组件加载顺序12// 加载渲染过程>父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted 12// 父组件更新过程 父beforeUpdate->父updated 12// 子组件更新过程父beforeUpdate->子beforeUpdate->子updated->父updated 12// 销毁过程父beforeDestroy->子beforeDestroy->子destroyed->父destroyed","link":"/%E5%8E%9F%E5%A7%8BMD/VUE%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86.html"},{"title":"mac端常用操作","text":"链接远程服务器在程序坞中右键终端图标，选择新建远程连接 选择「安全Shell（ssh）」 上传文件（夹）到远程服务器在程序坞中右键终端图标，选择新建远程连接 选择「安全文件传输（sftp）」 一、远程->本地12341、文件scp username@servername:/path/filename /localhost/filename2、目录scp -r username@servername:/path /localhoster 二、本地->远程12341、文件scp /localhost/filename username@servername:/path/filename2、目录scp -r /localhost username@servername:/path","link":"/%E5%8E%9F%E5%A7%8BMD/mac%E7%AB%AF%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html"},{"title":"vue3.0与2.x对比","text":"一、 为什么重写vue2.X?尤雨溪的回答是两个关键因素： 主流浏览器对新的JavaScript语言特性的普遍支持。 当前Vue代码库随着时间的推移而暴露出来的设计和体系架构问题。 二、Vue2.x 到 Vue3 详细对比2.1- 生命周期的变化 Vue2.x Vue3 beforeCreate 使用 setup() created 使用 setup() beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeDestroy onBeforeUnmount destroyed onUnmounted errorCaptured onErrorCaptured 使用setup代替了之前的beforeCreate和created，其他生命周期名字有些变化 2.2- 使用proxy代替definePropertyvue2.x双向绑定的核心是Object.defineProperty() 2.2.1- Object.defineProperty()语法重点：vue为什么对数组对象的深层监听无法实现，因为组件每次渲染都是将data里的数据通过defineProperty双向绑定上，之前没有后加的属性是不会被绑定上，也就不会触发更新渲染 1234567891011Object.defineProperty( Obj, 'name', { enumerable: true, configurable: true, get: function () { return def }, set: function ( val ) { def = val }} ) 2.2.2- Proxy的语法123456789101112const handler = { get: function(obj, prop) { return prop in obj ? obj[prop] : 37; }, set:function(){ }, ...13个配置项};const p = new Proxy({}, handler);p.a = 1;p.b = undefined;console.log(p.a, p.b);console.log('c' in p, p.c); defineProperty只能绑定首次渲染时候的属性，Proxy需要的是整体，不需要关心里面有什么属性，而且Proxy的配置项有13种，可以做更细致的事情，这是之前的defineProperty无法达到的 2.2.3- 两者兼容性1.vue2.x之所以只能兼容到IE8就是因为defineProperty无法兼容IE8,其他浏览器也会存在轻微兼容问题 2.proxy的话除了IE，其他浏览器都兼容 2.3- Diff算法的提升2.3.1- 以往的渲染策略vue2.x提供类似于HTML的模板语法，但是，它是将模板编译成渲染函数来返回虚拟DOM树。Vue框架通过递归遍历两个虚拟DOM树，并比较每个节点上的每个属性，来确定实际DOM的哪些部分需要更新。 2.3.2- 潜在的问题由于现代JavaScript引擎执行的高级优化，这种有点暴力的算法通常非常快速，但是DOM的更新仍然涉及许多不必要的CPU工作，那么如何解决呢？ 2.3.3- Vue3的突破引用尤雨溪： 为了实现这一点，编译器和运行时需要协同工作：编译器分析模板并生成带有优化提示的代码，而运行时尽可能获取提示并采用快速路径。这里有三个主要的优化： 首先，在DOM树级别。我们注意到，在没有动态改变节点结构的模板指令（例如v-if和v-for）的情况下，节点结构保持完全静态。如果我们将一个模板分成由这些结构指令分隔的嵌套”块”，则每个块中的节点结构将再次完全静态。当我们更新块中的节点时，我们不再需要递归遍历DOM树 - 该块内的动态绑定可以在一个平面数组中跟踪。这种优化通过将需要执行的树遍历量减少一个数量级来规避虚拟DOM的大部分开销。 其次，编译器积极地检测模板中的静态节点、子树甚至数据对象，并在生成的代码中将它们提升到渲染函数之外。这样可以避免在每次渲染时重新创建这些对象，从而大大提高内存使用率并减少垃圾回收的频率。 第三，在元素级别。编译器还根据需要执行的更新类型，为每个具有动态绑定的元素生成一个优化标志。例如，具有动态类绑定和许多静态属性的元素将收到一个标志，提示只需要进行类检查。运行时将获取这些提示并采用专用的快速路径。 综合起来，这些技术大大改进了我们的渲染更新基准，Vue 3有时占用的CPU时间不到Vue 2的十分之一。 2.4- typeScript的支持2.4.1- 存在的问题vue2.x中使用的都是js，并没有类型系统这个概念，现如今typescript异常火爆，它的崛起是有原因的，因为对于规模很大的项目，没有类型声明，后期维护和代码的阅读都是头疼的事情，所以广大码农迫切的需要vue能完美支持ts。 2.4.2- 如何实现最终vue3 借鉴了react hook实现了更自由的编程方式，提出了Composition API，Composition API不需要通过指定一长串选项来定义组件，而是允许用户像编写函数一样自由地表达、组合和重用有状态的组件逻辑，同时提供出色的TypeScript支持。 2.5- 打包体积变化2.5.1- 以前打包存在的问题vue2官方说的运行时打包师23k，但这只是没安装依赖的时候，随着依赖包和框架特性的增多，有时候不必要的，未使用的代码文件都被打包了进去，所以后期项目大了，打包文件会特别多还很大。 2.5.2- vue3是怎么做的引用尤雨溪： 在Vue 3中，我们通过将大多数全局API和内部帮助程序移动到Javascript的module.exports属性上实现这一点。这允许现代模式下的module bundler能够静态地分析模块依赖关系，并删除与未使用的module.exports属性相关的代码。模板编译器还生成了对树抖动友好的代码，只有在模板中实际使用某个特性时，该代码才导入该特性的帮助程序。 尽管增加了许多新特性，但Vue 3被压缩后的基线大小约为10 KB，不到Vue 2的一半。 2.6-其他Api和功能的改动注释：这些小改动就不做更细的说明，只列举下。 详细使用看vue2的迁移部分 Global API 模板指令 组件 渲染函数 vue-cli 从 v4.5.0 开始提供 Vue 3 预设 Vue Router 4.0 提供了 Vue 3 支持，并有许多突破性的变化 Vuex 4.0 提供了 Vue 3 支持，其 API 与 2.x 基本相同","link":"/%E5%8E%9F%E5%A7%8BMD/vue3-0%E4%B8%8E2-x%E5%AF%B9%E6%AF%94.html"},{"title":"云服务器配置部署前端项目实践","text":"从零搭建前端项目运行环境 登录服务器 安装node下载Node.js安装包 12$ cd /usr/local/src/$ wget https://nodejs.org/dist/v10.15.3/node-v10.15.3-linux-x64.tar.xz 解压文件1$ tar xvf node-v10.15.3-linux-x64.tar.xz 创建软链接12$ ln -s /home/node-v10.15.3-linux-x64.tar.xz/bin/node /usr/local/bin/node$ ln -s /home/node-v10.15.3-linux-x64.tar.xz/bin/npm /usr/local/bin/npm 验证1$ node -v 安装nginx 安装nginx相关的依赖12$ yum -y install gcc pcre-devel zlib-devel openssl openssl-devel 安装nginx相关的依赖12$ cd /usr/local/src/$ wget http://nginx.org/download/nginx-1.16.0.tar.gz 解压文件1$ tar -zxvf zlib-1.16.0.tar.gz 编译1234//进入nginx$ cd nginx-1.16.0$ ./configure$ make install 启动12$ cd /usr/local/nginx/sbin/$ ./nginx 安装pm212345$ npm install -g pm2 命令行全局安装pm2$ pm2 start app.js 或者 pm2 start bin/www 启动node项目$ pm2 stop bin/www 停止pm2服务$ pm2 list 列出由pm2管理的所有进程信息，还会显示一个进程会被启动多少次，因为没处理的异常。","link":"/%E5%8E%9F%E5%A7%8BMD/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5.html"},{"title":"手写 Promise","text":"1. Promise 的基本特征： promise 有三个状态：pending，fulfilled，or rejected；「规范 Promise/A+ 2.1」 new promise时， 需要传递一个executor()执行器，执行器立即执行； executor接受两个参数，分别是resolve和reject；. promise 的默认状态是 pending； promise 有一个value保存成功状态的值，可以是undefined/thenable/promise；「规范 Promise/A+ 1.3」 promise 有一个reason保存失败状态的值；「规范 Promise/A+ 1.5」 promise 只能从pending到rejected, 或者从pending到fulfilled，状态一旦确认，就不会再改变； promise 必须有一个then方法，then 接收两个参数，分别是 promise 成功的回调 onFulfilled, 和 promise 失败的回调 onRejected；「规范 Promise/A+ 2.2」 如果调用 then 时，promise 已经成功，则执行onFulfilled，参数是promise的value； 如果调用 then 时，promise 已经失败，那么执行onRejected, 参数是promise的reason； 如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调onRejected； 2. 简单实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 三个状态：PENDING、FULFILLED、REJECTEDconst PENDING = 'PENDING';const FULFILLED = 'FULFILLED';const REJECTED = 'REJECTED';class Promise { constructor(executor) { // 默认状态为 PENDING this.status = PENDING; // 存放成功状态的值，默认为 undefined this.value = undefined; // 存放失败状态的值，默认为 undefined this.reason = undefined; // 调用此方法就是成功 let resolve = (value) => { // 状态为 PENDING 时才可以更新状态，防止 executor 中调用了两次 resovle/reject 方法 if(this.status === PENDING) { this.status = FULFILLED; this.value = value; } } // 调用此方法就是失败 let reject = (reason) => { // 状态为 PENDING 时才可以更新状态，防止 executor 中调用了两次 resovle/reject 方法 if(this.status === PENDING) { this.status = REJECTED; this.reason = reason; } } try { // 立即执行，将 resolve 和 reject 函数传给使用者 executor(resolve,reject) } catch (error) { // 发生异常时执行失败逻辑 reject(error) } } // 包含一个 then 方法，并接收两个参数 onFulfilled、onRejected then(onFulfilled, onRejected) { if (this.status === FULFILLED) { onFulfilled(this.value) } if (this.status === REJECTED) { onRejected(this.reason) } }} 3. 测试12345678910const promise = new Promise((resolve, reject) => { resolve('成功');}).then( (data) => { console.log('success', data) }, (err) => { console.log('faild', err) })","link":"/%E5%8E%9F%E5%A7%8BMD/%E6%89%8B%E5%86%99Promise.html"},{"title":"前端命名规范","text":"促进项目中名称命名统一 参考 ant-design参考 element UI 类型 规则 项目名 全小写，中划线 eg: ant-design 文件夹名 全小写，中划线 eg: page-header 文件名 全小写，中划线 包括图片，html，js等 组件名 大驼峰 eg: TimePicker.vue id class 全小写，中划线 header-logo 类名 大驼峰 eg: Student 方法名 小驼峰 eg: getUserInfo() 变量名 小驼峰 userInfo 常量名 全大写 下划线 MAX_COUNT class命名考虑使用公司简称或项目简称作为前缀 常用单词布局整体布局：layout、wrapper上下左中右：top、bottom、left、center、right容器：container、box页头：header页面主体：main页脚：footer侧边栏：sidebar竖栏目：col导航：nav菜单：menu内容条：bar 模块标题：title内容：content列表：list按钮：btn输入框：input标签：label切换标签：tab图标：icon背景：bg对话框：dialog提示：tip消息：msg注释：note描述：disc","link":"/%E5%8E%9F%E5%A7%8BMD/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.html"},{"title":"日常问题速记","text":"日常问题及解决方案或知识点 UI框架组件方法中绑定默认参数，此时传参会覆盖掉默认参数 解决方案1@close=\"(e) => {deleteNode(e ,item.id)}\" // e 默认参数 item.id自定义参数 常见HTTP状态码 123456789101112131415161718192021export default { 200: '请求被正确处理并返回了结果', 201: '新增或修改数据成功', 202: '请求已进入任务队列，被异步处理', 203: '令牌或登录状态失效', 204: '删除数据成功', 301: '请求的资源被永久重定向到新的位置，将从新的地址重新请求', 302: '请求的资源被临时重定向到新的位置', 400: '请求参数错误，服务器没有对数据做新建或修改', 401: '无访问权限，用户名、密码、令牌错误', 403: '得到访问授权，但访问是被禁止', 404: '访问的是不存在的资源', 405: '请求方式不正确', 406: '请求的数据格式不是服务接收的类型', 410: '请求的资源被永久删除', 422: '服务器创建对象时发生错误', 500: '服务器不可用，未返回正确的数据', 502: '服务器网关错误', 503: '服务器过载或维护中', 504: '服务器响应超时', } 使用UI框架的弹框组件时，index.vue中引入组件，组件的生命周期就会开始执行，但是往往这是组件处于隐藏状态，导致引用插件无法获取到dom节点而报错 案例 index.vue 1234567 DetailModel.vue 123 mounted () { this.$echarts.init(document.getElementById('chart')) // 初始化图表获取dom节点报错}, 解决方案1234567 < /div>< /html> 12345 mounted () { this.$nextTick(() => { //使用nextTick函数 this.$echarts.init(document.getElementById('chart')) })}, 根据分数 计算等级 50 ==>E95 ==>A123scoreLevel (score) { return (score < 0 || score > 100) ? 'ERROR' : { 10: 'A', 9: 'A', 8: 'B', 7: 'C', 6: 'D' }[~~(score / 10)] || 'E'}, 空位合并运算符 ??a ?? b 的结果是：如果 a 是已定义的，则结果为 a， 如果 a 不是已定义的，则结果为 b。 与 || 比较|| 返回第一个 真 值。 ?? 返回第一个 已定义的 值。 123let length=0length || '数据异常' //数据异常length ?? '数据异常' //0 可选链运算符Cannot read property XXX of undefined，抛出无法从未定义的数据中读取某个字段 可选链运算符在查找嵌套对象时，找到链中的第一个undefined或者null后会立即终止，并返回undefined，而不会不断向下查找而导致抛错 123456const obj = { foo: { bar: 123 } }console.log(obj?.fo?.bar) //undefinedconsole.log(obj.fo.bar) //Uncaught TypeError: Cannot read property 'bar' of undefined 无法打开 http://*.github.io现在无法打开 *.http://github.io 原因是电信运营商 DNS 污染（域名指往不正确的IP地址） 这次应该是运营商行为。像封某歌是国家行为。 可以通过修改 hosts文件 / 修改DNS服务器 / 代理 的方式访问。 可将 DNS 修改为 114.114.114.114，一个良心 DNS 服务商。 但大多数访客是不会进行上方操作的。作为站长，还是使用域名为好，服务器不稳定可以方便地更换服务商。","link":"/%E5%8E%9F%E5%A7%8BMD/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E9%80%9F%E8%AE%B0.html"},{"title":"跨域及解决方案","text":"跨域定义 跨域:即请求的地址与被请求的地址协议头、域名、端口有一个不一样就叫跨域.相反,不跨域即叫同源,同源:即协议头（http/https）、域名、端口完全一致就叫同源; 跨域解决方案 跨域解决方案 1、 通过jsonp跨域2、 document.domain + iframe跨域3、 location.hash + iframe4、 window.name + iframe跨域5、 postMessage跨域6、 跨域资源共享（CORS）7、 nginx代理跨域8、 nodejs中间件代理跨域9、 WebSocket协议跨域 一、 通过jsonp跨域通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。 1.）原生实现： var script = document.createElement(‘script’); script.type = ‘text/javascript’; // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数 script.src = &apos;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&apos;; document.head.appendChild(script); // 回调执行函数 function handleCallback(res) { alert(JSON.stringify(res)); } 服务端返回如下（返回时即执行全局函数）： handleCallback({“status”: true, “user”: “admin”})2.）jquery ajax： $.ajax({ url: ‘http://www.domain2.com:8080/login', type: ‘get’, dataType: ‘jsonp’, // 请求方式为jsonp jsonpCallback: “handleCallback”, // 自定义回调函数名 data: {}});3.）vue.js： this.$http.jsonp(‘http://www.domain2.com:8080/login', { params: {}, jsonp: ‘handleCallback’}).then((res) => { console.log(res);})后端node.js代码示例： var querystring = require(‘querystring’);var http = require(‘http’);var server = http.createServer(); server.on(‘request’, function(req, res) { var params = qs.parse(req.url.split(‘?’)[1]); var fn = params.callback; // jsonp返回设置 res.writeHead(200, { 'Content-Type': 'text/javascript' }); res.write(fn + '(' + JSON.stringify(params) + ')'); res.end(); }); server.listen(‘8080’);console.log(‘Server is running at port 8080…’);jsonp缺点：只能实现get一种请求。 二、 document.domain + iframe跨域此方案仅限主域相同，子域不同的跨域应用场景。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 1.）父窗口：(http://www.domain.com/a.html) document.domain = ‘domain.com’; var user = ‘admin’;2.）子窗口：(http://child.domain.com/b.html) document.domain = ‘domain.com’; // 获取父窗口中变量 alert(‘get js data from parent —&gt; ‘ + window.parent.user);三、 location.hash + iframe跨域实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。 1.）a.html：(http://www.domain1.com/a.html) var iframe = document.getElementById(‘iframe’); // 向b.html传hash值 setTimeout(function() { iframe.src = iframe.src + &apos;#user=admin&apos;; }, 1000); // 开放给同域c.html的回调方法 function onCallback(res) { alert(&apos;data from c.html ---&gt; &apos; + res); } 2.）b.html：(http://www.domain2.com/b.html) var iframe = document.getElementById(‘iframe’); // 监听a.html传来的hash值，再传给c.html window.onhashchange = function () { iframe.src = iframe.src + location.hash; }; 3.）c.html：(http://www.domain1.com/c.html) // 监听b.html传来的hash值 window.onhashchange = function () { // 再通过操作同域a.html的js回调，将结果传回 window.parent.parent.onCallback(‘hello: ‘ + location.hash.replace(‘#user=’, ‘’)); };四、 window.name + iframe跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 1.）a.html：(http://www.domain1.com/a.html) var proxy = function(url, callback) { var state = 0; var iframe = document.createElement(‘iframe’); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() { if (state === 1) { // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); } else if (state === 0) { // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = 'http://www.domain1.com/proxy.html'; state = 1; } }; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() { iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); } }; // 请求跨域b页面数据proxy(‘http://www.domain2.com/b.html', function(data){ alert(data);});2.）proxy.html：(http://www.domain1.com/proxy....中间代理页，与a.html同域，内容为空即可。 3.）b.html：(http://www.domain2.com/b.html) window.name = ‘This is domain2 data!’;总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 五、 postMessage跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：a.） 页面和其打开的新窗口的数据传递b.） 多窗口之间消息传递c.） 页面与嵌套的iframe消息传递d.） 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 1.）a.html：(http://www.domain1.com/a.html) var iframe = document.getElementById(‘iframe’); iframe.onload = function() { var data = { name: ‘aym’ }; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), ‘http://www.domain2.com'); }; // 接受domain2返回数据 window.addEventListener(&apos;message&apos;, function(e) { alert(&apos;data from domain2 ---&gt; &apos; + e.data); }, false); 2.）b.html：(http://www.domain2.com/b.html) // 接收domain1的数据 window.addEventListener(‘message’, function(e) { alert(‘data from domain1 —&gt; ‘ + e.data); var data = JSON.parse(e.data); if (data) { data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), &apos;http://www.domain1.com&apos;); } }, false); 六、 跨域资源共享（CORS）普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。 需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。 目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。 1、 前端设置：1.）原生ajax // 前端设置是否带cookiexhr.withCredentials = true;示例代码： var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容 // 前端设置是否带cookiexhr.withCredentials = true; xhr.open(‘post’, ‘http://www.domain2.com:8080/login', true);xhr.setRequestHeader(‘Content-Type’, ‘application/x-www-form-urlencoded’);xhr.send(‘user=admin’); xhr.onreadystatechange = function() { if (xhr.readyState == 4 && xhr.status == 200) { alert(xhr.responseText); }};2.）jQuery ajax $.ajax({ … xhrFields: { withCredentials: true // 前端设置是否带cookie }, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie …});3.）vue框架 a.) axios设置： axios.defaults.withCredentials = trueb.) vue-resource设置： Vue.http.options.credentials = true2、 服务端设置：若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。 1.）Java后台： /* 导入包：import javax.servlet.http.HttpServletResponse; 接口参数中定义：HttpServletResponse response*/ // 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加’/‘response.setHeader(“Access-Control-Allow-Origin”, “","link":"/%E5%8E%9F%E5%A7%8BMD/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"},{"title":"Markdown Nice使用教程","text":"1 Markdown Nice 简介支持自定义样式的 Markdown 编辑器支持微信公众号、知乎和稀土掘金2 主题「https://product.mdnice.com/themes/」欢迎提交主题，提供更多文章示例~~3 通用语法3.1 标题在文字写书写不同数量的#可以完成不同的标题，如下：一级标题二级标题三级标题3.2 无序列表无序列表的使用，在符号-后加空格使用。如下：无序列表 1无序列表 2无序列表 3如果要控制列表的层级，则需要在符号-前使用空格。如下：无序列表 1无序列表 2无序列表 2.1无序列表 2.2「由于微信原因，最多支持到二级列表」。3.3 有序列表有序列表的使用，在数字及符号.后加空格后输入内容，如下：有序列表 1有序列表 2有序列表 33.4 粗体和斜体粗体的使用是在需要加粗的文字前后各加两个。而斜体的使用则是在需要斜体的文字前后各加一个。如果要使用粗体和斜体，那么就是在需要操作的文字前后加三个*。如下：「这个是粗体」这个是斜体「这个是粗体加斜体」注：由于 commonmark 标准，可能会导致加粗与想象不一致，如下今天天气好晴朗，处处好风光。这个是正常现象，请参考加粗 Issue[1]。3.5 链接微信公众号仅支持公众号文章链接，即域名为https://mp.weixin.qq.com/的合法链接。使用方法如下所示：对于该论述，欢迎读者查阅之前发过的文章，你是《未来世界的幸存者》么？3.6 引用引用的格式是在符号 > 后面书写文字，文字的内容可以包含标题、链接、图片、粗体和斜体等。一级引用如下：❝一级引用示例读一本好书，就是在和高尚的人谈话。 「——歌德」❞当使用多个 > 符号时，就会变成多级引用二级引用如下：二级引用示例读一本好书，就是在和高尚的人谈话。 「——歌德」Markdown Nice最全功能介绍三级引用如下：三级引用示例读一本好书，就是在和高尚的人谈话。 「——歌德」Markdown Nice最全功能介绍3.7 分割线可以在一行中用三个以上的减号来建立一个分隔线，同时需要在分隔线的上面空一行。如下：3.8 删除线删除线的使用，在需要删除的文字前后各使用两个~，如下：这是要被删除的内容。3.9 表格可以使用冒号来定义表格的对齐方式，如下：姓名年龄工作小可爱18吃可爱多小小勇敢20爬棵勇敢树小小小机智22看一本机智书宽度过长的表格可以滚动，可在自定义主题中调节宽度：姓名年龄工作邮箱手机小可爱18吃可爱多lovely@test.com18812345678小小勇敢20爬棵勇敢树brave@test.com17712345678小小小机智22看一本机智书smart@test.com166123456783.10 图片插入图片，如果是行内图片则无图例，否则有图例，格式如下：这里写图片描述可以通过在图片尾部添加宽度和高度控制图片大小，用法如下：同时设置宽度和高度只设置宽度，推荐使用百分比该语法比较特殊，其他 Markdown 编辑器不完全通用。支持 jpg、png、gif、svg 等图片格式，「其中 svg 文件仅可在微信公众平台中使用」，svg 文件示例如下：支持图片「拖拽和截图粘贴」到编辑器中上传，上传时使用当前选择的图床。可使用「格式->图片」上传本地图片，网站目前支持「图壳」图床，失败率低，但是只可保存一天用于排版「注：仅支持 https 的图片，图片粘贴到微信、知乎或掘金时会自动上传其服务器，不必担心使用上述图床会导致图片丢失」。图片还可以和链接嵌套使用，能够实现推荐卡片的效果，用法如下：Markdown Nice 最全功能介绍4. 特殊语法4.1 脚注❝支持平台：微信公众号、知乎。❞脚注与链接的区别如下所示：链接：文字脚注：文字有人认为在大前端时代[2]的背景下，移动端开发（Android、IOS）将逐步退出历史舞台。全栈工程师[3]在业务开发流程中起到了至关重要的作用。脚注内容请拉到最下面观看。4.2 代码块❝支持平台：微信公众号、知乎。❞如果在一个行内需要引用代码，只要用反引号引起来就好，如下：Use the printf() function.在需要高亮的代码块的前一行及后一行使用三个反引号，同时「第一行反引号后面表示代码块所使用的语言」，如下：// FileName: HelloWorld.javapublic class HelloWorld { // Java 入口程序，程序从此入口 public static void main(String[] args) { System.out.println(“Hello,World!”); // 向控制台打印一条语句 }}支持以下语言种类：bashclojure，cpp，cs，cssdart，dockerfile, differlanggo，gradle，groovyhaskelljava，javascript，json，juliakotlinlisp，luamakefile，markdown，matlabobjectivecperl，php，pythonr，ruby，rustscala，shell，sql，swifttex，typescriptverilog，vhdlxmlyaml如果想要更换代码主题，可在上方挑选，不支持代码主题自定义。其中「微信代码主题与微信官方一致」，有以下注意事项：带行号且不换行，代码大小与官方一致需要在代码块处标志语言，否则无法高亮粘贴到公众号后，用鼠标点代码块内外一次，完成高亮diff 不能同时和其他语言的高亮同时显示，且需要调整代码主题为微信代码主题以外的代码主题才能看到 diff 效果，使用效果如下:+ 新增项- 删除项「其他主题不带行号，可自定义是否换行，代码大小与当前编辑器一致」4.3 数学公式❝支持平台：微信公众号、知乎。❞行内公式使用方法，比如这个化学公式：块公式使用方法如下：矩阵：公式由于微信不支持，目前的解决方案是转成 svg 放到微信中，无需调整，矢量不失真。目前测试如果公式量过大，在 Chrome 下会存在粘贴后无响应，但是在 Firefox 中始终能够成功。4.4 TOC❝支持平台：微信公众号、知乎。❞TOC 全称为 Table of Content，列出全部标题。由于示例标题过多，需要使用将下方代码段去除即可。[TOC]由于微信只支持到二级列表，本工具仅支持二级标题和三级标题的显示。4.5 注音符号❝支持平台：微信公众号。❞支持注音符号，用法如下：Markdown Nice 这么好用，简直是喜大普奔hē hē hē hē呀！4.6 横屏滑动幻灯片❝支持平台：微信公众号。❞通过这种语法设置横屏滑动滑动片，具体用法如下：< 左右滑动见更多 >>>","link":"/%E5%8E%9F%E5%A7%8BMD/MD%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html"}],"posts":[{"title":"一像素","text":"产生原因由于分辨率 DPI 的差异，高清手机屏上的 1px 实际上是由 2×2 个像素点来渲染，有的屏幕甚至用到了 3×3 个像素点所以 border: 1px 在移动端会渲染为 2px 的边框解决方案一 (不推荐) 使用高度为 1px 的图片代替 1234.border-bottom-1px { border-width: 0 0 1px 0; border-image: url(1px.png) 0 0 2 0 stretch;} 解决方案二通过 js 获取到设备像素比，然后动态添加 标签 ，控制缩放 123456789101112(function() { var scale = 1.0; if (window.devicePixelRatio === 2) { scale *= 0.5; } if (window.devicePixelRatio === 3) { scale *= 0.333333; } var text = ''; document.write(text); })(); 解决方案三 (推荐)使用伪类 :after 创建 1px 的边框，后通过 媒体查询（media） 适配不同的设备像素比 123456789101112131415161718192021222324252627282930313233.border-bottom-1px { position: relative;}.border-bottom-1px::after { content: ' '; position: absolute; left: 0; bottom: 0; width: 100%; height: 1px; background-color: #222;}/* 1.5倍屏 */@media only screen and (-webkit-min-device-pixel-ratio: 1.5) { .border-bottom::after { -webkit-transform: scaleY(0.7); transform: scaleY(0.7); }}/* 2倍屏 */@media only screen and (-webkit-min-device-pixel-ratio: 2) { .border-bottom::after { -webkit-transform: scaleY(0.5); transform: scaleY(0.5); }}/* 3倍屏 */@media only screen and (-webkit-min-device-pixel-ratio: 3) { .border-bottom::after { -webkit-transform: scaleY(0.33); transform: scaleY(0.33); }}","link":"/2019/01/10/01.%E4%B8%80%E5%83%8F%E7%B4%A0/"},{"title":"axios","text":"axios 1234567891011121314axios({ method: 'post', url: 'xxxxxx', data: { a: 'data1', b: 'data2' }}) .then(function(response) { console.log(response) //请求成功 }) .catch(function(error) { console.log(error) //请求失败 }) 执行 GET 请求12345678910111213// 为给定 ID 的 user 创建请求axios .get('/user', { params: { ID: 12345 } }) .then(function(response) { console.log(response) }) .catch(function(error) { console.log(error) }) 1234567891011### 执行 POST 请求axios.post('/user', { ID: '1234'}).then(function (response) { console.log(response);}).catch(function (error) { console.log(error);});","link":"/2019/01/17/03.axios/"},{"title":"MarkDown教程","text":"Markdown 是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown 兼容html语言 基础语法一、标题123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 二、字体1234**这是加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~ 这是加粗的文字这是倾斜的文字这是斜体加粗的文字这是加删除线的文字 三、引用1> 引用的内容 这段文字是引用的内容… 四、分割线1234-------******** ***，— 三个以上，效果相同 五、超链接，图片123超链接: [文字](url)图片:[文字](url)图片超链接: ![[百度 https://www.baidu.com](https://www.baidu.com)](https://img-bss.csdn.net/201901101629501036.png) 超链接示例百度 https://www.baidu.com 图片示例 六、列表1. 无序列表1234- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 列表内容 列表内容 列表内容 2. 有序列表12341. 列表内容2. 列表内容3. 列表内容25. 列表内容 列表内容 列表内容 列表内容 列表内容 七. 表格1234表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容 表头 表头 表头 表头 表头 表头 内容 内容 内容 内容 内容 内容 内容 内容 内容 内容 内容 内容 八. 代码高亮1单行代码 `代码内容` 单行代码 console.log('') 1234567891011getUserInfo () { this.Post({ url: this.apiNames['获取用户信息'], data: {}, success: (data) => { if (data.responseStatus.resultCode === 0) { this.userInfo = data.userInfo } } })}","link":"/2018/12/20/06.MarkDown%E6%95%99%E7%A8%8B/"},{"title":"关于SPA,SEO,SSR","text":"前后端分离开发的大趋势下催生几个概念：SPA、SEO和SSR SPA(single page web application 单页Web应用)SPA是一种 网络应用程序(WebApp)模型。在传统的网站中，不同的页面之间的切换都是直接从服务器加载一整个新的页面，而在SPA这个模型中，是通过动态地重写页面的部分与用户交互，而避免了过多的数据交换，响应速度自然相对更高 特点 速度：更好的用户体验，让用户在web app感受native app的速度和流畅， MVVM：经典MVVM开发模式，前后端各负其责。 ajax：重前端，业务逻辑全部在本地操作，数据都需要通过AJAX同步、提交。 路由：在URL中采用#号来作为当前视图的地址,改变#号后的参数，页面并不会重载 目前常见的几个SPA框架 AngularJS React Vue.js SPA的优点 基本上前面所说的前后端分离的优点它都有，另外还有以下的一些优点 页面之间的切换非常快 一定程度上减少了后端服务器的压力（不用管页面逻辑和渲染） 后端程序只需要提供API，完全不用管客户端到底是Web界面还是手机等 SPA的缺点 首屏打开速度很慢，因为用户首次加载需要先下载SPA框架及应用程序的代码，然后再渲染页面。 不利于SEO SEO（Search Engine Optimization 搜索引擎优化）SEO是一种通过了解搜索引擎的运作规则（如何抓取网站页面，如何索引以及如何根据特定的关键字展现搜索结果排序等）来调整网站，以提高该网站在搜索引擎中某些关键词的搜索结果排名。 搜索引擎工作原理在搜索引擎网站，比如百度，在其后台有一个非常庞大的数据库，里面存储了海量的关键词，而每个关键词又对应着很多网址，这些网址是百度程序从茫茫的互联网上一点一点下载收集而来的，这些程序称之为“搜索引擎蜘蛛”或“网络爬虫”。这些勤劳的“蜘蛛”每天在互联网上爬行，从一个链接到另一个链接，下载其中的内容，进行分析提炼，找到其中的关键词，如果“蜘蛛”认为关键词在数据库中没有而对用户是有用的便存入数据库。反之，如果“蜘蛛”认为是垃圾信息或重复信息，就舍弃不要，继续爬行，寻找最新的、有用的信息保存起来提供用户搜索。当用户搜索时，就能检索出与关键字相关的网址显示给访客。 一个关键词对用多个网址，因此就出现了排序的问题，相应的当与关键词最吻合的网址就会排在前面了。在“蜘蛛”抓取网页内容，提炼关键词的这个过程中，就存在一个问题：“蜘蛛”能否看懂。如果网站内容是flash和js，那么它是看不懂的，会犯迷糊，即使关键字再贴切也没用。相应的，如果网站内容是它的语言，那么它便能看懂，它的语言即SEO。 1 1 矛盾点在当前前端趋势下，SPA一般只有一个主页面，内容由js获取，不便于搜索引擎获取 SPA应用中，通常通过AJAX获取数据，而这里就难以保证我们的页面能被搜索引擎正常收录到。并且有一些搜索引擎不支持执行JS和通过AJAX获取数据，那就更不用提SEO了 SSR (Server-Side Rendering 服务器端渲染）在普通的SPA中，一般是将框架及网站页面代码发送到浏览器，然后在浏览器中生成和操作DOM（这里也是第一次访问SPA网站在同等带宽及网络延迟下比传统的在后端生成HTML发送到浏览器要更慢的主要原因），但其实也可以将SPA应用打包到服务器上，在服务器上渲染出HTML，发送到浏览器，这样的HTML页面还不具备交互能力，所以还需要与SPA框架配合，在浏览器上“混合”成可交互的应用程序。所以，只要能合理地运用SSR技术，不仅能一定程度上解决首屏慢的问题，还能获得更好的SEO SSR的优点 更快的响应时间，不用等待所有的JS都下载完成，浏览器便能显示比较完整的页面了。 更好的SSR，我们可以将SEO的关键信息直接在后台就渲染成HTML，而保证搜索引擎的爬虫都能爬取到关键数据。 SSR的缺点 相对于仅仅需要提供静态文件的服务器，SSR中使用的渲染程序自然会占用更多的CPU和内存资源 一些常用的浏览器API可能无法正常使用，比如window、docment和alert等，如果使用的话需要对运行的环境加以判断 开发调试会有一些麻烦，因为涉及了浏览器及服务器，对于SPA的一些组件的生命周期的管理会变得复杂 可能会由于某些因素导致服务器端渲染的结果与浏览器端的结果不一致。 SSR常用框架 React 的 Next Vue.js 的 Nuxt 参考 浅谈SPA、SEO、SSR 百度百科","link":"/2019/01/11/02.%E5%85%B3%E4%BA%8ESPA,SEO,SSR/"},{"title":"rem使用","text":"项目中使用rem需要引入自动换算js 比例100：1 100px=1rem12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//自定义设计稿的宽度：designWidth//最大宽度:maxWidth//这段js的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为750，最大宽度为750，则为(750,750);(function(designWidth, maxWidth) { var doc = document, win = window, docEl = doc.documentElement, remStyle = document.createElement(\"style\"), tid; function refreshRem() { var width = docEl.getBoundingClientRect().width; maxWidth = maxWidth || 540; width>maxWidth && (width=maxWidth); var rem = width * 100 / designWidth; remStyle.innerHTML = 'html{font-size:' + rem + 'px;}'; } if (docEl.firstElementChild) { docEl.firstElementChild.appendChild(remStyle); } else { var wrap = doc.createElement(\"div\"); wrap.appendChild(remStyle); doc.write(wrap.innerHTML); wrap = null; } //要等 wiewport 设置好后才能执行 refreshRem，不然 refreshRem 会执行2次； refreshRem(); win.addEventListener(\"resize\", function() { clearTimeout(tid); //防止执行两次 tid = setTimeout(refreshRem, 300); }, false); win.addEventListener(\"pageshow\", function(e) { if (e.persisted) { // 浏览器后退的时候重新计算 clearTimeout(tid); tid = setTimeout(refreshRem, 300); } }, false); if (doc.readyState === \"complete\") { doc.body.style.fontSize = \"16px\"; } else { doc.addEventListener(\"DOMContentLoaded\", function(e) { doc.body.style.fontSize = \"16px\"; }, false); }})(750, 750);","link":"/2019/01/15/07.rem%E4%BD%BF%E7%94%A8/"},{"title":"前端面试","text":"面试准备及技巧一. 面试前简历及面试准备假如你要面试一个公司，他们主招 Vue 技术栈的前端开发，那么你的简历里面只有 Vue 这个名词是不够的，最好能体现出 Vue 的生态来。这样写就不错：熟练使用 ElementUI＋Vue＋Vuex 开发项目，Webpack 构建项目，Nuxtjs 做服务端渲染。 简历中出现的技术一定要能说出个一二三，不要一问三不知 简历堆砌技术名词其实是一把双刃剑： 不写技术名词，简历容易被刷掉； 写上的话，可是需要充分的准备哦，否则这可能成为你的软肋； 写进简历的项目一定要了如指掌 项目的前期构建， 总结项目开发中遇到的问题及解决思路 在项目中学到的经验 项目的打包上线部署 二. 面试 落落大方，面试是公司选你，也是你选公司的过程。工作可以不要，气势不能丢 准备一段自我介绍 几句个人简介，名字毕业学校，工作经验，上家公司 主要负责的工作 换工作的原因及预期 具备常用算法，数组操作，经典css布局等的手写能力 对前端技术实现原理，底层，优缺点的理解 既然你熟练使用VUE 那vue有什么优缺点 职业规划 你有什么问题想问我？ 三. 面试总结 面试千篇一律，善于总结方能立于不败之地","link":"/2019/01/16/08.%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"},{"title":"vue.js中$watch的oldvalue与newValue","text":"由于vue内部机制，导致对象或数组改变时旧值将与新值相同vue.js文档中指出 详情>> 解决方案一，this.$set 方法二，Object.assign()方法三，计算属性 computed1234567export default { data () { return { msg: 'Highlighted!' } }}","link":"/2018/12/11/04.vue.$watch%E5%80%BC%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/"},{"title":"浮生六记","text":"衡量爱情的标准，从来只有一个 贾平凹说过：人，可以无知，但不可以无趣。 一本《浮生六记》让我认识了一位有趣的文人——沈复： 他，才情出众，既有文人风雅，亦有稚童心态，虽半生潦倒，依然和夫人将清贫的生活过得热气腾腾。 地上两只虫子打架，沈复聚精会神地看了半天，还琢磨人家为什么打架，难道有奸情？一只癞蛤蟆跳了过来，长舌一卷，把虫子吞进了肚子。看得入迷的沈复，被吓了一跳。等回过神，气得咬牙切齿：“好你个癞蛤蟆，坏了我看虫的雅兴！”逮到蛤蟆胖揍了一番，撵出院子，方才泄愤。 夏日里到处飞的蚊子，在他的凝视下，都幻化成端庄的白鹤，在空中翩翩起舞，他扬起一抹迷之微笑，突然灵光一闪: 没有白云，白鹤飞个什么劲？赶紧把蚊子轰到蚊帐里，搞点烟雾，蚊帐里顿时“仙气”缭绕。顾不上自己被熏得眼泪汪汪，看着蚊子冲破烟雾飞翔，他心满意足地大笑起来：“这才是白鹤飞在青云上啊！”所谓有趣——是对细小事物的全神贯注是天马行空的狂想是奋不顾身的热爱。 01有趣的人，一粥一菜都是温存沈复爱吃蒜，芸娘不吃。 日子久了，芸娘被沈复的蒜味“熏陶”得受不了，也跟着吃蒜。 如此一来，两人耳鬓厮磨时，就不会嫌弃彼此浓郁的口气了。 芸娘爱吃腐乳酱瓜，便让沈复也尝尝。 奈何腐乳闻着臭气烘烘，沈复将吃腐乳比作“狗吃屎”，芸娘气坏了： “我跟着你吃臭大蒜，你却不陪我吃腐乳，还骂我是狗。” 架不住娇妻的投诉，沈复硬着头皮“当了一回狗”。 入口后，腐乳独特的咸鲜香辣，让他如释重负，原来闻着臭的东西，吃起来的味道妙不可言。 从此，大蒜、腐乳成了二人餐桌上的美食。 芸娘的堂姐出嫁，沈复去观礼。 忙到大半夜，他饿得眼冒金星，到处找吃的。 芸娘神秘地对沈复招手，将他带到自己的闺房，变戏法一般从柜子里端出了一锅清粥，一碟小菜。 沈复两眼放光，激动坏了，就差给芸娘跪了高呼“万岁”。 当时，两人尚未成亲， 一个大男人躲在大姑娘的房里吃东西，还是低调点好。 沈复压住狂喜，挽起袖子食指大动，芸娘的脸上飞起一抹红云，笑颜如花。 沈复一生清贫，清粥咸菜是家常便饭，只要和心上人一起吃，粗茶淡饭亦可饕餮。 一粥一菜里都是温存。 02有趣的人，花草虫石，处处美好沈复爱好花草，放在现代，他就是“花痴”。 菊花盛放时，他会剪下来做插花。 每个花瓶只插一个品种，一种颜色，单数花枝。 经沈复之手完成的插花作品，或亭亭玉立，或飞舞横斜，姿态万千，错落有致。 在他卧室的床头，常年有一瓶雅致的插花，都是他的作品。 家里的锅碗瓢盆，也是沈复搞艺术创作的素材。 沈复对虫子是真爱。他的艺术作品怎能少了虫子的身影？ 他和芸娘去抓螳螂和蝴蝶，用细丝把它们栓起来绑在花草上，还不忘给虫子凹造型： 蝴蝶的翅膀要展开一点才有韵味，螳螂的双臂要高举才威武。 经沈复的用心打造，花草虫石，完美地组合在一起，精致且富有活力，让人赞不绝口。 一花一草，一石一虫，都是大自然的馈赠。 有人熟视无睹，有人视若珍宝。 有趣的人，总能懂得花草虫石，都是生活的美好。 03有趣的人，嬉笑玩闹，不拘世俗有一次，水仙庙要举行庆典。 因插花水平一流，朋友邀请沈复布置插花。 沈复想让芸娘同去，就在她跟前鼓吹： “这场夜宴，花色明艳，光影流离，吹奏笙箫，欢歌唱闹，好玩得很！” 芸娘心动，出于旧俗，顾虑女人不便去，沈复狡黠一笑： “戴我的冠，穿我的衣，化女为男，我们一起去！” 他把芸娘的发髻散开，改为辫子，将他的帽子戴在妻子头上，长衫略长不要紧，从腰间打折缝起来，外头再套个马褂，就看不出来了。 沈复又给妻子买了时髦的“蝴蝶靴”，男女都可以穿。 芸娘担心婆婆知道了会生气，沈复拍着胸脯担保： “怕什么？老太太走亲戚去了，我俩悄悄走，悄悄回，他们怎么知道？再说了，庙里管事的都是我朋友，就算识破你是女人家，还不是一笑了之？” 芸娘这才欣然前往。 有趣的人，洒脱不羁，不为世俗所阻。 芸娘守旧礼，对待丈夫十分恭敬。 沈复不在乎那么多规矩，他就喜欢拉着妻子的手，咬个耳朵，说点情话，温情地给妻子整理衣袖。 每次这么做，芸娘都拘谨地说“岂敢”，沈复逗趣她“礼多必诈”。 两口子路上遇见了，沈复就拱手作揖，说声“得罪”，芸娘心神领会，屈膝回礼来句“岂敢”。 两句敬辞，被夫妻二人玩成了口头禅。 有趣的人，之乎者也、繁文缛节也是一种雅兴和情怀。 04有趣的人，以诗下酒，印章传情红袖添香，诗酒相伴，是文人墨客的标配，沈复也不例外。 他看书写字时，芸娘就研磨沏茶。 他好喝两口小酒，芸娘虽不善饮酒，但放开怀也能喝上几杯。 为了让妻子陪自己小酌，沈复教她行酒令“射覆”，类似现代的摇骰子猜数字，两人玩得不亦乐乎，谁输了谁喝酒，以诗下酒，好不快活。 沈复还喜欢和妻子“讨论学术”，他鼓励且欣赏妻子有自己的见解和评判。 两人曾讨论过，谁才是唐诗界的扛把子。 沈复选了沉稳的杜甫，芸娘则喜欢活泼的李白。 沈复吃醋地调侃说： “想不到，我的老婆竟然是李太白的拥趸”，芸娘笑着安抚他：“你字称三白，也带个‘白’字。我的诗歌启蒙来源于白居易，再加上李太白，你们这三白，都是我崇敬的人。” 才子佳人，精神相交便不过如此了。 沈复工作不稳定，偶尔去外地给人当幕僚，夫妻两地分居的日子里，鸿雁传书就是他和芸娘互诉衷肠的方式。 沈复亲手打造了朱白两枚印章，章面写着“愿生生世世为夫妇”，他拿的是阳文，妻子拿的是阴文。 写完信，拿出印章，呵一口气，用力地盖在信笺上，整颗心也跟着印了上去。 印章都是情侣款，这种境界的秀恩爱，也是前无古人后无来者了。 有趣的人，诗词可下酒，印章能传情，生活处处有情调。 05有趣，是做人的最高配置林语堂将《浮生六记》视为知己并评价说： “读沈复的书，使我感到这安乐的奥妙，远超乎尘俗之压迫与人身之痛苦。” 很多人喜欢沈复，是被《浮生六记》中的烟火江南，闺房趣事所吸引。 他笔下妙趣横生、温情款款的片段，让大家都不由地感慨： 浮生若梦，做人还是有趣的好。 《沉默的大多数》中有句话： 我活在世上，无非想明白些道理，遇见些有趣的事。 有趣的人，才能遇见有趣的事。 感谢沈复教会我们，做个有趣之人，桃花树下，酒烫茶温；布衣菜饭，可乐终身。 不论生活贫穷还是富裕，顺境还是逆境，用心生活，把平凡无奇的日子过成精彩纷呈的段子。","link":"/2019/06/11/09.%E6%B5%AE%E7%94%9F%E5%85%AD%E8%AE%B0/"},{"title":"ESlint报错解决方案","text":"Unary operator ‘++’ usedESLint 不允许++ 运算比如1234567891011for (let i = 0; i < 3; i ++) { // ...}for (let i = 0; i < 3; i += 1) { // ...}temp++var temp = 0;temp += 1; Missing radix parameter 缺少基数参数ESLint parseInt()方法必须传入第二参数radix1234parseInt(string, radix)parseInt('123', 0)radix 取值范围2~36代表数字基数不传或传0代表10进制–传入0可解决parseInt(‘123’, 0) Unexpected string concatenation 意外的字符串连接不允许字符串拼接1'0' + month ======》`0${month}`; Expected to return a value in arrow function 箭头函数期望有返回值使用map时Eslint希望有返回值123columns.map(item => { item.name='xx'});1：用Object.keys(this.props.ntn).forEach去替换.map，因为ESLint array-callback-return这个警告是因为在使用map, filter , reduce 没有去返回一个值。 2：当然也可以使用map,在react中用jsx的方式，直接把{}改成()即可。 扩展map:和forEach非常相似，都是用来遍历数组中的每一项值的，用来遍历数组中的每一项；区别：map的回调函数中支持return返回值；return的是啥，相当于把数组中的这一项变为啥（并不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了）；不管是forEach还是map 都支持第二个参数值，第二个参数的意思是把匿名回调函数中的this进行修改。 JSX props should not use .bind() JSX语法中不能使用.bind() ERROR 1 SUCCESS Option 1: Use arrow functions (with babel-plugins) PS:- Experimental feature 1234567891011121314class MyComponent extends Component { handleClick = (args) => () => { // access args here; // handle the click event } render() { return ( ..... ) }}Option 2: Not recommended Define arrow functions in render 123456789101112class MyComponent extends Component { render() { const handleClick = () => { // handle the click event } return ( ..... ) } } Option 3: Use binding in constructor 12345678910111213141516171819class MyComponent extends Component { constructor() { super(); this.handleClick = this.handleClick.bind(this); } handleClick() { // handle click } render() { return ( ..... ) } }","link":"/2019/06/18/10.ESlint%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"JavaScript进阶问题列表","text":"JavaScript 进阶问题列表 摘自github 从基础到进阶，测试你有多了解 JavaScript，刷新你的知识，或者帮助你的 coding 面试！ 答案在问题下方的折叠部分，点击即可展开问题。祝你好运 1. 输出是什么？12345678function sayHi() { console.log(name) console.log(age) var name = 'Lydia' let age = 21}sayHi() A: Lydia 和 undefined B: Lydia 和 ReferenceError C: ReferenceError 和 21 D: undefined 和 ReferenceError 答案#### 答案: D在函数内部，我们首先通过 var 关键字声明了 name 变量。这意味着变量被提升了（内存空间在创建阶段就被设置好了），直到程序运行到定义变量位置之前默认值都是 undefined。因为当我们打印 name 变量时还没有执行到定义变量的位置，因此变量的值保持为 undefined。通过 let 和 const 关键字声明的变量也会提升，但是和 var 不同，它们不会被初始化。在我们声明（初始化）之前是不能访问它们的。这个行为被称之为暂时性死区。当我们试图在声明之前访问它们时，JavaScript 将会抛出一个 ReferenceError 错误。 2. 输出是什么？1234567for (var i = 0; i < 3; i++) { setTimeout(() => console.log(i), 1)}for (let i = 0; i < 3; i++) { setTimeout(() => console.log(i), 1)} A: 0 1 2 和 0 1 2 B: 0 1 2 和 3 3 3 C: 3 3 3 和 0 1 2 答案#### 答案: C由于 JavaScript 的事件循环，setTimeout 回调会在遍历结束后才执行。因为在第一个遍历中遍历 i 是通过 var 关键字声明的，所以这个值是全局作用域下的。在遍历过程中，我们通过一元操作符 ++ 来每次递增 i 的值。当 setTimeout 回调执行的时候，i 的值等于 3。在第二个遍历中，遍历 i 是通过 let 关键字声明的：通过 let 和 const 关键字声明的变量是拥有块级作用域（指的是任何在 {} 中的内容）。在每次的遍历过程中，i 都有一个新值，并且每个值都在循环内的作用域中。 3. 输出是什么？12345678910const shape = { radius: 10, diameter() { return this.radius * 2 }, perimeter: () => 2 * Math.PI * this.radius}shape.diameter()shape.perimeter() A: 20 and 62.83185307179586 B: 20 and NaN C: 20 and 63 D: NaN and 63 答案#### 答案: B注意 diameter 的值是一个常规函数，但是 perimeter 的值是一个箭头函数。对于箭头函数，this 关键字指向的是它当前周围作用域（简单来说是包含箭头函数的常规函数，如果没有常规函数的话就是全局对象），这个行为和常规函数不同。这意味着当我们调用 perimeter 时，this 不是指向 shape 对象，而是它的周围作用域（在例子中是 window）。在 window 中没有 radius 这个属性，因此返回 undefined。 4. 输出是什么？12;+true!'Lydia' A: 1 and false B: false and NaN C: false and false 答案#### 答案: A一元操作符加号尝试将 bool 转为 number。true 转换为 number 的话为 1，false 为 0。字符串 'Lydia' 是一个真值，真值取反那么就返回 false。 5. 哪一个是无效的？12345678const bird = { size: 'small'}const mouse = { name: 'Mickey', small: true} A: mouse.bird.size B: mouse[bird.size] C: mouse[bird[\"size\"]] D: All of them are valid 答案#### 答案: A在 JavaScript 中，所有对象的 keys 都是字符串（除非对象是 Symbol）。尽管我们可能不会定义它们为字符串，但它们在底层总会被转换为字符串。当我们使用括号语法时（[]），JavaScript 会解释（或者 unboxes）语句。它首先看到第一个开始括号 [ 并继续前进直到找到结束括号 ]。只有这样，它才会计算语句的值。mouse[bird.size]：首先计算 bird.size，这会得到 small。mouse[\"small\"] 返回 true。然后使用点语法的话，上面这一切都不会发生。mouse 没有 bird 这个 key，这也就意味着 mouse.bird 是 undefined。然后当我们使用点语法 mouse.bird.size 时，因为 mouse.bird 是 undefined，这也就变成了 undefined.size。这个行为是无效的，并且会抛出一个错误类似 Cannot read property \"size\" of undefined。 6. 输出是什么？123456let c = { greeting: 'Hey!' }let dd = cc.greeting = 'Hello'console.log(d.greeting) A: Hello B: undefined C: ReferenceError D: TypeError 答案#### 答案: A在 JavaScript 中，当设置两个对象彼此相等时，它们会通过引用进行交互。首先，变量 c 的值是一个对象。接下来，我们给 d 分配了一个和 c 对象相同的引用。因此当我们改变其中一个对象时，其实是改变了所有的对象。 7. 输出是什么？1234567let a = 3let b = new Number(3)let c = 3console.log(a == b)console.log(a === b)console.log(b === c) A: true false true B: false false true C: true false false D: false true true 答案#### 答案: Cnew Number() 是一个内建的函数构造器。虽然它看着像是一个 number，但它实际上并不是一个真实的 number：它有一堆额外的功能并且它是一个对象。当我们使用 == 操作符时，它只会检查两者是否拥有相同的值。因为它们的值都是 3，因此返回 true。然后，当我们使用 === 操作符时，两者的值以及类型都应该是相同的。new Number() 是一个对象而不是 number，因此返回 false。 8. 输出是什么？12345678910111213class Chameleon { static colorChange(newColor) { this.newColor = newColor return this.newColor } constructor({ newColor = 'green' } = {}) { this.newColor = newColor }}const freddie = new Chameleon({ newColor: 'purple' })freddie.colorChange('orange') A: orange B: purple C: green D: TypeError 答案#### 答案: DcolorChange 是一个静态方法。静态方法被设计为只能被创建它们的构造器使用（也就是 Chameleon），并且不能传递给实例。因为 freddie 是一个实例，静态方法不能被实例使用，因此抛出了 TypeError 错误。 9. 输出是什么？123let greetinggreetign = {} // Typo!console.log(greetign) A: {} B: ReferenceError: greetign is not defined C: undefined 答案#### 答案: A代码打印出了一个对象，这是因为我们在全局对象上创建了一个空对象！当我们将 greeting 写错成 greetign 时，JS 解释器实际在上浏览器中将它视为 global.greetign = {} （或者 window.greetign = {}）。为了避免这个为题，我们可以使用 `”use strict”。这能确保当你声明变量时必须赋值。 10. 当我们这么做时，会发生什么？12345function bark() { console.log('Woof!')}bark.animal = 'dog' A: Nothing, this is totally fine! B: SyntaxError. You cannot add properties to a function this way. C: undefined D: ReferenceError 答案#### 答案: A这在 JavaScript 中是可以的，因为函数是对象！（除了基本类型之外其他都是对象）函数是一个特殊的对象。你写的这个代码其实不是一个实际的函数。函数是一个拥有属性的对象，并且属性也可被调用。 11. 输出是什么？1234567891011function Person(firstName, lastName) { this.firstName = firstName; this.lastName = lastName;}const member = new Person(\"Lydia\", \"Hallie\");Person.getFullName = function () { return `${this.firstName} ${this.lastName}`;}console.log(member.getFullName()); A: TypeError B: SyntaxError C: Lydia Hallie D: undefined undefined 答案#### 答案: A你不能像常规对象那样，给构造函数添加属性。如果你想一次性给所有实例添加特性，你应该使用原型。因此本例中，使用如下方式：123Person.prototype.getFullName = function () { return `${this.firstName} ${this.lastName}`;}这才会使 member.getFullName() 起作用。为什么这么做有益的？假设我们将这个方法添加到构造函数本身里。也许不是每个 Person 实例都需要这个方法。这将浪费大量内存空间，因为它们仍然具有该属性，这将占用每个实例的内存空间。相反，如果我们只将它添加到原型中，那么它只存在于内存中的一个位置，但是所有实例都可以访问它！ 12. 输出是什么？12345678910function Person(firstName, lastName) { this.firstName = firstName this.lastName = lastName}const lydia = new Person('Lydia', 'Hallie')const sarah = Person('Sarah', 'Smith')console.log(lydia)console.log(sarah) A: Person {firstName: \"Lydia\", lastName: \"Hallie\"} and undefined B: Person {firstName: \"Lydia\", lastName: \"Hallie\"} and Person {firstName: \"Sarah\", lastName: \"Smith\"} C: Person {firstName: \"Lydia\", lastName: \"Hallie\"} and {} D:Person {firstName: \"Lydia\", lastName: \"Hallie\"} and ReferenceError 答案#### 答案: A对于 sarah，我们没有使用 new 关键字。当使用 new 时，this 引用我们创建的空对象。当未使用 new 时，this 引用的是全局对象（global object）。我们说 this.firstName 等于 \"Sarah\"，并且 this.lastName 等于 \"Smith\"。实际上我们做的是，定义了 global.firstName = 'Sarah' 和 global.lastName = 'Smith'。而 sarah 本身是 undefined。 13. 事件传播的三个阶段是什么？ A: Target > Capturing > Bubbling B: Bubbling > Target > Capturing C: Target > Bubbling > Capturing D: Capturing > Target > Bubbling 答案#### 答案: D在捕获（capturing）阶段中，事件从祖先元素向下传播到目标元素。当事件达到目标（target）元素后，冒泡（bubbling）才开始。 14. 所有对象都有原型。 A: true B: false 答案#### 答案: B除了基本对象（base object），所有对象都有原型。基本对象可以访问一些方法和属性，比如 .tostring。这就是为什么你可以使用内置的 JavaScript 方法！所有这些方法在原型上都是可用的。虽然 JavaScript 不能直接在对象上找到这些方法，但 JavaScript 会沿着原型链找到它们，以便于你使用。 15. 输出是什么？12345function sum(a, b) { return a + b}sum(1, '2') A: NaN B: TypeError C: \"12\" D: 3 答案#### 答案: CJavaScript 是一种动态类型语言：我们不指定某些变量的类型。值可以在你不知道的情况下自动转换成另一种类型，这种类型称为隐式类型转换（implicit type coercion）。Coercion 是指将一种类型转换为另一种类型。在本例中，JavaScript 将数字 1 转换为字符串，以便函数有意义并返回一个值。在数字类型（1）和字符串类型（'2'）相加时，该数字被视为字符串。我们可以连接字符串，比如 \"Hello\" + \"World\"，这里发生的是 \"1\" + \"2\"，它返回 \"12\"。 16. 输出是什么？1234let number = 0console.log(number++)console.log(++number)console.log(number) A: 1 1 2 B: 1 2 2 C: 0 2 2 D: 0 1 2 答案#### 答案: C一元后自增运算符 ++：1. 返回值（返回 0）2. 值自增（number 现在是 1）一元前自增运算符 ++：1. 值自增（number 现在是 2）2. 返回值（返回 2）结果是 0 2 2. 17. 输出是什么？12345678910function getPersonInfo(one, two, three) { console.log(one) console.log(two) console.log(three)}const person = 'Lydia'const age = 21getPersonInfo`${person} is ${age} years old` A: \"Lydia\" 21 [\"\", \" is \", \" years old\"] B: [\"\", \" is \", \" years old\"] \"Lydia\" 21 C: \"Lydia\" [\"\", \" is \", \" years old\"] 21 答案#### 答案: B如果使用标记模板字面量，第一个参数的值总是包含字符串的数组。其余的参数获取的是传递的表达式的值！ 18. 输出是什么？1234567891011function checkAge(data) { if (data === { age: 18 }) { console.log('You are an adult!') } else if (data == { age: 18 }) { console.log('You are still an adult.') } else { console.log(`Hmm.. You don't have an age I guess`) }}checkAge({ age: 18 }) A: You are an adult! B: You are still an adult. C: Hmm.. You don't have an age I guess 答案#### 答案: C在测试相等性时，基本类型通过它们的值（value）进行比较，而对象通过它们的引用（reference）进行比较。JavaScript 检查对象是否具有对内存中相同位置的引用。题目中我们正在比较的两个对象不是同一个引用：作为参数传递的对象引用的内存位置，与用于判断相等的对象所引用的内存位置并不同。这也是 { age: 18 } === { age: 18 } 和 { age: 18 } == { age: 18 } 都返回 false 的原因。 19. 输出是什么？12345function getAge(...args) { console.log(typeof args)}getAge(21) A: \"number\" B: \"array\" C: \"object\" D: \"NaN\" 答案#### 答案: C扩展运算符（...args）会返回实参组成的数组。而数组是对象，因此 typeof args 返回 \"object\"。 20. 输出是什么？1234567function getAge() { 'use strict' age = 21 console.log(age)}getAge() A: 21 B: undefined C: ReferenceError D: TypeError 答案#### 答案: C使用 \"use strict\"，你可以确保不会意外地声明全局变量。我们从来没有声明变量 age，因为我们使用 \"use strict\"，它将抛出一个引用错误。如果我们不使用 \"use strict\"，它就会工作，因为属性 age 会被添加到全局对象中了。 21. 输出是什么？1const sum = eval('10*10+5') A: 105 B: \"105\" C: TypeError D: \"10*10+5\" 答案#### 答案: A代码以字符串形式传递进来，eval 对其求值。如果它是一个表达式，就像本例中那样，它对表达式求值。表达式是 10 * 10 + 5。这将返回数字 105。 22. cool_secret 可访问多长时间？1sessionStorage.setItem('cool_secret', 123) A: Forever, the data doesn’t get lost. B: When the user closes the tab. C: When the user closes the entire browser, not only the tab. D: When the user shuts off their computer. 答案#### 答案: B关闭 tab 标签页 后，sessionStorage 存储的数据才会删除。如果使用 localStorage，那么数据将永远在那里，除非调用了 localStorage.clear()。 23. 输出是什么？1234var num = 8var num = 10console.log(num) A: 8 B: 10 C: SyntaxError D: ReferenceError 答案#### 答案: B使用 var 关键字，你可以用相同的名称声明多个变量。然后变量将保存最新的值。你不能使用 let 或 const 来实现这一点，因为它们是块作用域的。 24. 输出是什么？1234567const obj = { 1: 'a', 2: 'b', 3: 'c' }const set = new Set([1, 2, 3, 4, 5])obj.hasOwnProperty('1')obj.hasOwnProperty(1)set.has('1')set.has(1) A: false true false true B: false true true true C: true true false true D: true true true true 答案#### 答案: C所有对象的键（不包括 Symbol）在底层都是字符串，即使你自己没有将其作为字符串输入。这就是为什么 obj.hasOwnProperty('1') 也返回 true。对于集合，它不是这样工作的。在我们的集合中没有 '1'：set.has('1') 返回 false。它有数字类型为 1，set.has(1) 返回 true。 25. 输出是什么？12const obj = { a: 'one', b: 'two', a: 'three' }console.log(obj) A: { a: \"one\", b: \"two\" } B: { b: \"two\", a: \"three\" } C: { a: \"three\", b: \"two\" } D: SyntaxError 答案#### 答案: C如果你有两个名称相同的键，则键会被替换掉。它仍然位于第一个键出现的位置，但是值是最后出现那个键的值。 26. JavaScript 全局执行上下文为你做了两件事：全局对象和 this 关键字。 A: true B: false C: it depends 答案#### 答案: A基本执行上下文是全局执行上下文：它是代码中随处可访问的内容。 27. 输出是什么？1234for (let i = 1; i < 5; i++) { if (i === 3) continue console.log(i)} A: 1 2 B: 1 2 3 C: 1 2 4 D: 1 3 4 答案#### 答案: C如果某个条件返回 true，则 continue 语句跳过本次迭代。 28. 输出是什么？1234567String.prototype.giveLydiaPizza = () => { return 'Just give Lydia pizza already!'}const name = 'Lydia'name.giveLydiaPizza() A: \"Just give Lydia pizza already!\" B: TypeError: not a function C: SyntaxError D: undefined 答案#### 答案: AString 是内置的构造函数，我们可以向它添加属性。我只是在它的原型中添加了一个方法。基本类型字符串被自动转换为字符串对象，由字符串原型函数生成。因此，所有 string(string 对象)都可以访问该方法！ 29. 输出是什么？12345678const a = {}const b = { key: 'b' }const c = { key: 'c' }a[b] = 123a[c] = 456console.log(a[b]) A: 123 B: 456 C: undefined D: ReferenceError 答案#### 答案: B对象的键被自动转换为字符串。我们试图将一个对象 b 设置为对象 a 的键，且相应的值为 123。然而，当字符串化一个对象时，它会变成 \"[Object object]\"。因此这里说的是，a[\"Object object\"] = 123。然后，我们再一次做了同样的事情，c 是另外一个对象，这里也有隐式字符串化，于是，a[\"Object object\"] = 456。然后，我们打印 a[b]，也就是 a[\"Object object\"]。之前刚设置为 456，因此返回的是 456。 30. 输出是什么？1234567const foo = () => console.log('First')const bar = () => setTimeout(() => console.log('Second'))const baz = () => console.log('Third')bar()foo()baz() A: First Second Third B: First Third Second C: Second First Third D: Second Third First 答案#### 答案: B我们有一个 setTimeout 函数，并首先调用它。然而，它是最后打印日志的。这是因为在浏览器中，我们不仅有运行时引擎，还有一个叫做 WebAPI 的东西。WebAPI 提供了 setTimeout 函数，也包含其他的，例如 DOM。将 callback 推送到 WebAPI 后，setTimeout 函数本身(但不是回调！)将从栈中弹出。现在，foo 被调用，打印 \"First\"。foo 从栈中弹出，baz 被调用. 打印 \"Third\"。WebAPI 不能随时向栈内添加内容。相反，它将回调函数推到名为 queue 的地方。这就是事件循环开始工作的地方。一个事件循环查看栈和任务队列。如果栈是空的，它接受队列上的第一个元素并将其推入栈。bar 被调用，打印 \"Second\"，然后它被栈弹出。 31. 当点击按钮时，event.target是什么？1234567 Click! A: Outer div B: Inner div C: button D: An array of all nested elements. 答案#### 答案: C导致事件的最深嵌套的元素是事件的 target。你可以通过 event.stopPropagation 来停止冒泡。 32. 当您单击该段落时，日志输出是什么？12345 Click here! A: p div B: div p C: p D: div 答案#### 答案: A如果我们点击 p，我们会看到两个日志：p 和 div。在事件传播期间，有三个阶段：捕获、目标和冒泡。默认情况下，事件处理程序在冒泡阶段执行（除非将 useCapture 设置为 true）。它从嵌套最深的元素向外传播。 33. 输出是什么？12345678const person = { name: 'Lydia' }function sayHi(age) { console.log(`${this.name} is ${age}`)}sayHi.call(person, 21)sayHi.bind(person, 21) A: undefined is 21 Lydia is 21 B: function function C: Lydia is 21 Lydia is 21 D: Lydia is 21 function 答案#### 答案: D使用这两种方法，我们都可以传递我们希望 this 关键字引用的对象。但是，.call 是立即执行的。.bind 返回函数的副本，但带有绑定上下文！它不是立即执行的。 34. 输出是什么？12345function sayHi() { return (() => 0)()}typeof sayHi() A: \"object\" B: \"number\" C: \"function\" D: \"undefined\" 答案#### 答案: BsayHi 方法返回的是立即执行函数(IIFE)的返回值.此立即执行函数的返回值是 0， 类型是 number参考：只有7种内置类型：null，undefined，boolean，number，string，object 和 symbol。 function 不是一种类型，函数是对象，它的类型是object。 35. 下面哪些值是 falsy?1234560new Number(0);('');(' ')new Boolean(false)undefined A: 0, '', undefined B: 0, new Number(0), '', new Boolean(false), undefined C: 0, '', new Boolean(false), undefined D: All of them are falsy 答案#### 答案: A只有 6 种 falsy 值:- undefined- null- NaN- 0- '' (empty string)- falseFunction 构造函数, 比如 new Number 和 new Boolean，是 truthy。 36. 输出是什么？1console.log(typeof typeof 1) A: \"number\" B: \"string\" C: \"object\" D: \"undefined\" 答案#### 答案: Btypeof 1 返回 \"number\"。typeof \"number\" 返回 \"string\"。 37. 输出是什么？123const numbers = [1, 2, 3]numbers[10] = 11console.log(numbers) A: [1, 2, 3, 7 x null, 11] B: [1, 2, 3, 11] C: [1, 2, 3, 7 x empty, 11] D: SyntaxError 答案#### 答案: C当你为数组设置超过数组长度的值的时候， JavaScript 会创建名为 “empty slots” 的东西。它们的值实际上是 undefined。你会看到以下场景：[1, 2, 3, 7 x empty, 11]这取决于你的运行环境（每个浏览器，以及 node 环境，都有可能不同） 38. 输出是什么？1234567891011;(() => { let x, y try { throw new Error() } catch (x) { ;(x = 1), (y = 2) console.log(x) } console.log(x) console.log(y)})() A: 1 undefined 2 B: undefined undefined undefined C: 1 1 2 D: 1 undefined undefined 答案#### 答案: Acatch 代码块接收参数 x。当我们传递参数时，这与之前定义的变量 x 不同 。这个 x 是属于 catch 块级作用域的。然后，我们将块级作用域中的变量赋值为 1，同时也设置了变量 y 的值。现在，我们打印块级作用域中的变量 x，值为 1。catch 块之外的变量 x 的值仍为 undefined， y 的值为 2。当我们在 catch 块之外执行 console.log(x) 时，返回 undefined，y 返回 2。 39. JavaScript 中的一切都是？ A: primitive or object B: function or object C: trick question! only objects D: number or object-答案 答案: AJavaScript 只有基本类型和对象。 基本类型包括 boolean, null, undefined, bigint, number, string, symbol。 40. 输出是什么？123456;[[0, 1], [2, 3]].reduce( (acc, cur) => { return acc.concat(cur) }, [1, 2]) A: [0, 1, 2, 3, 1, 2] B: [6, 1, 2] C: [1, 2, 0, 1, 2, 3] D: [1, 2, 6] 答案#### 答案: C[1, 2]是初始值。初始值将会作为首次调用时第一个参数 acc 的值。在第一次执行时， acc 的值是 [1, 2]， cur 的值是 [0, 1]。合并它们，结果为 [1, 2, 0, 1]。第二次执行， acc 的值是 [1, 2, 0, 1]， cur 的值是 [2, 3]。合并它们，最终结果为 [1, 2, 0, 1, 2, 3] 41. 输出是什么？123!!null!!''!!1 A: false true false B: false false true C: false true true D: true true false 答案#### 答案: Bnull 是 falsy。 !null 的值是 true。 !true 的值是 false。\"\" 是 falsy。 !\"\" 的值是 true。 !true 的值是 false。1 是 truthy。 !1 的值是 false。 !false 的值是 true。 42. setInterval 方法的返回值是什么？1setInterval(() => console.log('Hi'), 1000) A: a unique id B: the amount of milliseconds specified C: the passed function D: undefined 答案#### 答案: AsetInterval 返回一个唯一的 id。此 id 可被用于 clearInterval 函数来取消定时。 43. 输出是什么？1;[...'Lydia'] A: [\"L\", \"y\", \"d\", \"i\", \"a\"] B: [\"Lydia\"] C: [[], \"Lydia\"] D: [[\"L\", \"y\", \"d\", \"i\", \"a\"]] 答案#### 答案: Astring 类型是可迭代的。扩展运算符将迭代的每个字符映射成一个元素。","link":"/2019/06/19/11.JavaScript%E8%BF%9B%E9%98%B6%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8/"},{"title":"VUE开发中遇到的问题","text":"对象数组深度监听❝问题: 后端传过来的数组是一个数组对象，页面中绑定对象中某一具体的属性，当该值变化时调用某个函数，自然想到就是watch方法。但如何watch数组对象中某一个具体的属性，显然不可能一个个属性写watch。❞解决办法：watch整个对象，设置deep为true，当该对象发生改变时，调用处理函数。将页面中绑定的属性写在computed函数中，watch这个computed中的函数，当对象值改变时会进入computed函数中，进而进入watch函数中，再调用处理函数。子组件生命周期执行顺序问题组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。组件的销毁操作是先父后子，销毁完成的顺序是先子后父。加载渲染过程父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount- >子mounted->父mounted子组件更新过程父beforeUpdate->子beforeUpdate->子updated->父updated父组件更新过程父 beforeUpdate -> 父 updated销毁过程父beforeDestroy->子beforeDestroy->子destroyed->父destroyed本地开发跨域问题❝问题: 在本地开发请求后端服务器接口的时候，都不可避免的会遇到跨域的问题。❞解决方法可以通过加一个node中间层或者nginx做反向代理。如果是用vue-cli搭建的项目，vue-cli在config中自带了一个proxyTable属性，可以配置这个属性解决跨域的问题。父组件控制子组件样式问题使用 xx /deep/ xx 或者 xx >>> xx对象赋值无法双向绑定例如对象obj ={a:1},如果想要修改obj中的a属性，通过obj.a = 2这样赋值，页面不会更新，需使用vue.set方法更改才会起作用， Vue.set(this,obj,a,2);同样，如果要给obj增加一个新属性，如果该属性未在data中声明，页面也不会刷新。也就是vue文档中声明的“Vue 不能检测到对象属性的添加或删除”，同样需要使用vue.set方法进行赋值才好使。Vue事件总线（eventBus）$on()会多次触发解决办法❝问题:注册的总线事件（Bus）,页面没有强制刷新，存在组件切换，bus.$on方法会被多次绑定，造成触发一次但多个响应的情况❞解决办法就是在利用接收事件的组件的或周期中将事件进行销毁，使用off()beforeDestroy () { bus.$off(‘BUS_NAME’)}附上github上Vue作者尤大大关于这问题的解答：https://github.com/vuejs/vue/issues/3399","link":"/2020/01/09/VUE%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"VUE知识点梳理","text":"1.对于MVVM的理解 MVVM 是 Model-View-ViewModel 的缩写 Model : 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为 View : 用户操作界面。当ViewModel对Model进行更新的时候，会通过数据绑定更新到View ViewModel ： 业务逻辑层，View需要什么数据，ViewModel要提供这个数据；View有某些操作，ViewModel就要响应这些操作，所以可以说它是Model for View.总结： MVVM模式简化了界面与业务的依赖，解决了数据频繁更新MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。 MVVM的缺点1.Bug很难被调试: 因为使用双向绑定的模式，当你看到界面异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。2.一个大的模块中model也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就造成了花费更多的内存3.对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高 2.VUE生命周期 beforeCreate （创建前）vue实例的挂载元素$el和数据对象 data都是undefined, 还未初始化 created (创建后) 完成了 data数据初始化, el还未初始化 beforeMount (载入前) vue实例的$el和data都初始化了, 相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。 mounted (载入后) 在el 被新创建的 vm.$el替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互 beforeUpdate (更新前) 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。 updated （更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 beforeDestroy (销毁前） 在实例销毁之前调用。实例仍然完全可用。 destroyed (销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 3.Vue实现数据双向绑定的原理 vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调 缺陷 Object.defineProperty 无法监听数组变化，通过劫持push()pop() shift() unshift() splice() sort() reverse() Object.defineProperty 只能劫持对象的属性,因此需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历 Proxy可以直接监听数组的变化 Proxy可以直接监听对象而非属性 4.vue-router 路由守卫 全局守卫 router.beforeEach 全局前置守卫 进入路由之前 router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用 router.afterEach 全局后置钩子 进入路由之后 路由独享守卫 路由定义是设置 123456789101112const router = new VueRouter({ routes: [ { path: '/foo', component: Foo, beforeEnter: (to, from, next) => { // 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖 // ... } } ] }) 路由组件内的守卫 beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 this，组件实例还没被创建 beforeRouteUpdate (2.2) 路由复用同一个组件时, 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 this beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this Vue的路由实现：hash模式 和 history模式 hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取； 特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。 hash 模式下，仅 hash 符号之前的内容会被包含在请求中，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。 history模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。 history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。 后端如果缺少对 /items/id 的路由处理，将返回 404 错误。 Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源： 如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。 组件之间的传值通信 1. 父组件给子组件传值 使用props，父组件可以使用props向子组件传递数据 1234567891011// parent// childexport default { props: { msg: { type: String, required: true } }} 2. 子组件向父组件通信123456789101112131415161718// 父组件vue模板 import child from './child.vue';export default { components: { child }, methods: { func (msg) { console.log(msg); } }} 123456789101112131415161718192021// 子组件vue模板 点我export default { props: { msg: { type: String, required: true } }, methods () { handleClick () { //........ this.$emit('msgFunc'); } }} 3. 非父子, 兄弟组件之间通信 使用Bus 或 vuex VUEX Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。有 5 种，分别是 state、getter、mutation、action、modulevuex 的 store 是什么？vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 datastate 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性vuex 的 getter 是什么？getter 可以对 state 进行计算操作，它就是 store 的计算属性虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用如果一个状态只在一个组件内使用，是可以不用 gettersvuex 的 mutation 是什么？更改Vuex的store中的状态的唯一方法是提交mutationvuex 的 action 是什么？action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态action 可以包含任意异步操作vue 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 action 中vuex 的 module 是什么？面对复杂的应用程序，当管理的状态比较多时；我们需要将vuex的store对象分割成模块(modules)。 父子组件加载顺序12// 加载渲染过程>父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted 12// 父组件更新过程 父beforeUpdate->父updated 12// 子组件更新过程父beforeUpdate->子beforeUpdate->子updated->父updated 12// 销毁过程父beforeDestroy->子beforeDestroy->子destroyed->父destroyed","link":"/2020/01/09/VUE%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"},{"title":"mac端常用操作","text":"链接远程服务器在程序坞中右键终端图标，选择新建远程连接选择「安全Shell（ssh）」上传文件（夹）到远程服务器在程序坞中右键终端图标，选择新建远程连接选择「安全文件传输（sftp）」一、远程->本地1、文件scp username@servername:/path/filename /localhost/filename2、目录scp -r username@servername:/path /localhoster二、本地->远程1、文件scp /localhost/filename username@servername:/path/filename2、目录scp -r /localhost username@servername:/path","link":"/2020/10/20/mac%E7%AB%AF%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"vue3.0与2.x对比","text":"一、 为什么重写vue2.X?尤雨溪的回答是两个关键因素： 主流浏览器对新的JavaScript语言特性的普遍支持。当前Vue代码库随着时间的推移而暴露出来的设计和体系架构问题。二、Vue2.x 到 Vue3 详细对比2.1- 生命周期的变化 Vue2.x Vue3 beforeCreate 使用 setup() created 使用 setup() beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeDestroy onBeforeUnmount destroyed onUnmounted errorCaptured onErrorCaptured 使用setup代替了之前的beforeCreate和created，其他生命周期名字有些变化2.2- 使用proxy代替definePropertyvue2.x双向绑定的核心是Object.defineProperty()2.2.1- Object.defineProperty()语法重点：vue为什么对数组对象的深层监听无法实现，因为组件每次渲染都是将data里的数据通过defineProperty双向绑定上，之前没有后加的属性是不会被绑定上，也就不会触发更新渲染Object.defineProperty( Obj, ‘name’, { enumerable: true, configurable: true, get: function () { return def }, set: function ( val ) { def = val }} )2.2.2- Proxy的语法const handler = { get: function(obj, prop) { return prop in obj ? obj[prop] : 37; }, set:function(){ }, …13个配置项};const p = new Proxy({}, handler);p.a = 1;p.b = undefined;console.log(p.a, p.b);console.log(‘c’ in p, p.c);defineProperty只能绑定首次渲染时候的属性，Proxy需要的是整体，不需要关心里面有什么属性，而且Proxy的配置项有13种，可以做更细致的事情，这是之前的defineProperty无法达到的2.2.3- 两者兼容性1.vue2.x之所以只能兼容到IE8就是因为defineProperty无法兼容IE8,其他浏览器也会存在轻微兼容问题2.proxy的话除了IE，其他浏览器都兼容2.3- Diff算法的提升2.3.1- 以往的渲染策略vue2.x提供类似于HTML的模板语法，但是，它是将模板编译成渲染函数来返回虚拟DOM树。Vue框架通过递归遍历两个虚拟DOM树，并比较每个节点上的每个属性，来确定实际DOM的哪些部分需要更新。2.3.2- 潜在的问题由于现代JavaScript引擎执行的高级优化，这种有点暴力的算法通常非常快速，但是DOM的更新仍然涉及许多不必要的CPU工作，那么如何解决呢？2.3.3- Vue3的突破引用尤雨溪： 为了实现这一点，编译器和运行时需要协同工作：编译器分析模板并生成带有优化提示的代码，而运行时尽可能获取提示并采用快速路径。这里有三个主要的优化： 首先，在DOM树级别。我们注意到，在没有动态改变节点结构的模板指令（例如v-if和v-for）的情况下，节点结构保持完全静态。如果我们将一个模板分成由这些结构指令分隔的嵌套”块”，则每个块中的节点结构将再次完全静态。当我们更新块中的节点时，我们不再需要递归遍历DOM树 - 该块内的动态绑定可以在一个平面数组中跟踪。这种优化通过将需要执行的树遍历量减少一个数量级来规避虚拟DOM的大部分开销。其次，编译器积极地检测模板中的静态节点、子树甚至数据对象，并在生成的代码中将它们提升到渲染函数之外。这样可以避免在每次渲染时重新创建这些对象，从而大大提高内存使用率并减少垃圾回收的频率。第三，在元素级别。编译器还根据需要执行的更新类型，为每个具有动态绑定的元素生成一个优化标志。例如，具有动态类绑定和许多静态属性的元素将收到一个标志，提示只需要进行类检查。运行时将获取这些提示并采用专用的快速路径。综合起来，这些技术大大改进了我们的渲染更新基准，Vue 3有时占用的CPU时间不到Vue 2的十分之一。2.4- typeScript的支持2.4.1- 存在的问题vue2.x中使用的都是js，并没有类型系统这个概念，现如今typescript异常火爆，它的崛起是有原因的，因为对于规模很大的项目，没有类型声明，后期维护和代码的阅读都是头疼的事情，所以广大码农迫切的需要vue能完美支持ts。2.4.2- 如何实现最终vue3 借鉴了react hook实现了更自由的编程方式，提出了Composition API，Composition API不需要通过指定一长串选项来定义组件，而是允许用户像编写函数一样自由地表达、组合和重用有状态的组件逻辑，同时提供出色的TypeScript支持。2.5- 打包体积变化2.5.1- 以前打包存在的问题vue2官方说的运行时打包师23k，但这只是没安装依赖的时候，随着依赖包和框架特性的增多，有时候不必要的，未使用的代码文件都被打包了进去，所以后期项目大了，打包文件会特别多还很大。2.5.2- vue3是怎么做的引用尤雨溪： 在Vue 3中，我们通过将大多数全局API和内部帮助程序移动到Javascript的module.exports属性上实现这一点。这允许现代模式下的module bundler能够静态地分析模块依赖关系，并删除与未使用的module.exports属性相关的代码。模板编译器还生成了对树抖动友好的代码，只有在模板中实际使用某个特性时，该代码才导入该特性的帮助程序。尽管增加了许多新特性，但Vue 3被压缩后的基线大小约为10 KB，不到Vue 2的一半。2.6-其他Api和功能的改动注释：这些小改动就不做更细的说明，只列举下。 详细使用看vue2的迁移部分Global API模板指令组件渲染函数vue-cli 从 v4.5.0 开始提供 Vue 3 预设Vue Router 4.0 提供了 Vue 3 支持，并有许多突破性的变化Vuex 4.0 提供了 Vue 3 支持，其 API 与 2.x 基本相同","link":"/2020/11/10/vue3-0%E4%B8%8E2-x%E5%AF%B9%E6%AF%94/"},{"title":"前端命名规范","text":"促进项目中名称命名统一 参考 ant-design参考 element UI 类型 规则 项目名 全小写，中划线 eg: ant-design 文件夹名 全小写，中划线 eg: page-header 文件名 全小写，中划线 包括图片，html，js等 组件名 大驼峰 eg: TimePicker.vue id class 全小写，中划线 header-logo 类名 大驼峰 eg: Student 方法名 小驼峰 eg: getUserInfo() 变量名 小驼峰 userInfo 常量名 全大写 下划线 MAX_COUNT class命名考虑使用公司简称或项目简称作为前缀 常用单词布局整体布局：layout、wrapper上下左中右：top、bottom、left、center、right容器：container、box页头：header页面主体：main页脚：footer侧边栏：sidebar竖栏目：col导航：nav菜单：menu内容条：bar 模块标题：title内容：content列表：list按钮：btn输入框：input标签：label切换标签：tab图标：icon背景：bg对话框：dialog提示：tip消息：msg注释：note描述：disc","link":"/2020/05/19/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"},{"title":"云服务器配置部署前端项目实践","text":"从零搭建前端项目运行环境 登录服务器 安装node下载Node.js安装包 12$ cd /usr/local/src/$ wget https://nodejs.org/dist/v10.15.3/node-v10.15.3-linux-x64.tar.xz 解压文件1$ tar xvf node-v10.15.3-linux-x64.tar.xz 创建软链接12$ ln -s /home/node-v10.15.3-linux-x64.tar.xz/bin/node /usr/local/bin/node$ ln -s /home/node-v10.15.3-linux-x64.tar.xz/bin/npm /usr/local/bin/npm 验证1$ node -v 安装nginx 安装nginx相关的依赖12$ yum -y install gcc pcre-devel zlib-devel openssl openssl-devel 安装nginx相关的依赖12$ cd /usr/local/src/$ wget http://nginx.org/download/nginx-1.16.0.tar.gz 解压文件1$ tar -zxvf zlib-1.16.0.tar.gz 编译1234//进入nginx$ cd nginx-1.16.0$ ./configure$ make install 启动12$ cd /usr/local/nginx/sbin/$ ./nginx 安装pm212345$ npm install -g pm2 命令行全局安装pm2$ pm2 start app.js 或者 pm2 start bin/www 启动node项目$ pm2 stop bin/www 停止pm2服务$ pm2 list 列出由pm2管理的所有进程信息，还会显示一个进程会被启动多少次，因为没处理的异常。","link":"/2020/05/20/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"},{"title":"日常问题速记","text":"… 日常问题及解决方案或知识点 UI框架组件方法中绑定默认参数，此时传参会覆盖掉默认参数 解决方案1@close=\"(e) => {deleteNode(e ,item.id)}\" // e 默认参数 item.id自定义参数 常见HTTP状态码123456789101112131415161718192021export default { 200: '请求被正确处理并返回了结果', 201: '新增或修改数据成功', 202: '请求已进入任务队列，被异步处理', 203: '令牌或登录状态失效', 204: '删除数据成功', 301: '请求的资源被永久重定向到新的位置，将从新的地址重新请求', 302: '请求的资源被临时重定向到新的位置', 400: '请求参数错误，服务器没有对数据做新建或修改', 401: '无访问权限，用户名、密码、令牌错误', 403: '得到访问授权，但访问是被禁止', 404: '访问的是不存在的资源', 405: '请求方式不正确', 406: '请求的数据格式不是服务接收的类型', 410: '请求的资源被永久删除', 422: '服务器创建对象时发生错误', 500: '服务器不可用，未返回正确的数据', 502: '服务器网关错误', 503: '服务器过载或维护中', 504: '服务器响应超时', } 使用UI框架的弹框组件时，index.vue中引入组件，组件的生命周期就会开始执行，但是往往这是组件处于隐藏状态，导致引用插件无法获取到dom节点而报错 案例 index.vue 1234567 DetailModel.vue 123 mounted () { this.$echarts.init(document.getElementById('chart')) // 初始化图表获取dom节点报错}, 解决方案1234567 < /div>< /html> 12345 mounted () { this.$nextTick(() => { //使用nextTick函数 this.$echarts.init(document.getElementById('chart')) })}, 根据分数 计算等级 50 ==>E95 ==>A123scoreLevel (score) { return (score < 0 || score > 100) ? 'ERROR' : { 10: 'A', 9: 'A', 8: 'B', 7: 'C', 6: 'D' }[~~(score / 10)] || 'E'}, 空位合并运算符 ??a ?? b 的结果是：如果 a 是已定义的，则结果为 a， 如果 a 不是已定义的，则结果为 b。 与 || 比较|| 返回第一个 真 值。 ?? 返回第一个 已定义的 值。 123let length=0length || '数据异常' //数据异常length ?? '数据异常' //0 可选链运算符Cannot read property XXX of undefined，抛出无法从未定义的数据中读取某个字段 可选链运算符在查找嵌套对象时，找到链中的第一个undefined或者null后会立即终止，并返回undefined，而不会不断向下查找而导致抛错 123456const obj = { foo: { bar: 123 } }console.log(obj?.fo?.bar) //undefinedconsole.log(obj.fo.bar) //Uncaught TypeError: Cannot read property 'bar' of undefined 无法打开 http://*.github.io现在无法打开 *.http://github.io 原因是电信运营商 DNS 污染（域名指往不正确的IP地址） 这次应该是运营商行为。像封某歌是国家行为。 可以通过修改 hosts文件 / 修改DNS服务器 / 代理 的方式访问。 可将 DNS 修改为 114.114.114.114，一个良心 DNS 服务商。 但大多数访客是不会进行上方操作的。作为站长，还是使用域名为好，服务器不稳定可以方便地更换服务商。","link":"/2020/07/09/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E9%80%9F%E8%AE%B0/"},{"title":"手写 Promise","text":"… 1. Promise 的基本特征：❝promise 有三个状态：pending，fulfilled，or rejected；「规范 Promise/A+ 2.1」new promise时， 需要传递一个executor()执行器，执行器立即执行；executor接受两个参数，分别是resolve和reject；.promise 的默认状态是 pending；promise 有一个value保存成功状态的值，可以是undefined/thenable/promise；「规范 Promise/A+ 1.3」promise 有一个reason保存失败状态的值；「规范 Promise/A+ 1.5」promise 只能从pending到rejected, 或者从pending到fulfilled，状态一旦确认，就不会再改变；promise 必须有一个then方法，then 接收两个参数，分别是 promise 成功的回调 onFulfilled, 和 promise 失败的回调 onRejected；「规范 Promise/A+ 2.2」如果调用 then 时，promise 已经成功，则执行onFulfilled，参数是promise的value；如果调用 then 时，promise 已经失败，那么执行onRejected, 参数是promise的reason；如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调onRejected；❞2. 简单实现// 三个状态：PENDING、FULFILLED、REJECTEDconst PENDING = ‘PENDING’;const FULFILLED = ‘FULFILLED’;const REJECTED = ‘REJECTED’;class Promise { constructor(executor) { // 默认状态为 PENDING this.status = PENDING; // 存放成功状态的值，默认为 undefined this.value = undefined; // 存放失败状态的值，默认为 undefined this.reason = undefined; // 调用此方法就是成功 let resolve = (value) => { // 状态为 PENDING 时才可以更新状态，防止 executor 中调用了两次 resovle/reject 方法 if(this.status === PENDING) { this.status = FULFILLED; this.value = value; } } // 调用此方法就是失败 let reject = (reason) => { // 状态为 PENDING 时才可以更新状态，防止 executor 中调用了两次 resovle/reject 方法 if(this.status === PENDING) { this.status = REJECTED; this.reason = reason; } } try { // 立即执行，将 resolve 和 reject 函数传给使用者 executor(resolve,reject) } catch (error) { // 发生异常时执行失败逻辑 reject(error) } } // 包含一个 then 方法，并接收两个参数 onFulfilled、onRejected then(onFulfilled, onRejected) { if (this.status === FULFILLED) { onFulfilled(this.value) } if (this.status === REJECTED) { onRejected(this.reason) } }}3. 测试const promise = new Promise((resolve, reject) => { resolve(‘成功’);}).then( (data) => { console.log(‘success’, data) }, (err) => { console.log(‘faild’, err) })","link":"/2020/07/16/%E6%89%8B%E5%86%99Promise/"},{"title":"跨域及解决方案","text":"跨域定义 跨域:即请求的地址与被请求的地址协议头、域名、端口有一个不一样就叫跨域.相反,不跨域即叫同源,同源:即协议头（http/https）、域名、端口完全一致就叫同源; 跨域解决方案 跨域解决方案 1、 通过jsonp跨域2、 document.domain + iframe跨域3、 location.hash + iframe4、 window.name + iframe跨域5、 postMessage跨域6、 跨域资源共享（CORS）7、 nginx代理跨域8、 nodejs中间件代理跨域9、 WebSocket协议跨域 一、 通过jsonp跨域通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。 1.）原生实现： var script = document.createElement(‘script’); script.type = ‘text/javascript’; // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数 script.src = &apos;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&apos;; document.head.appendChild(script); // 回调执行函数 function handleCallback(res) { alert(JSON.stringify(res)); } 服务端返回如下（返回时即执行全局函数）： handleCallback({“status”: true, “user”: “admin”})2.）jquery ajax： $.ajax({ url: ‘http://www.domain2.com:8080/login', type: ‘get’, dataType: ‘jsonp’, // 请求方式为jsonp jsonpCallback: “handleCallback”, // 自定义回调函数名 data: {}});3.）vue.js： this.$http.jsonp(‘http://www.domain2.com:8080/login', { params: {}, jsonp: ‘handleCallback’}).then((res) => { console.log(res);})后端node.js代码示例： var querystring = require(‘querystring’);var http = require(‘http’);var server = http.createServer(); server.on(‘request’, function(req, res) { var params = qs.parse(req.url.split(‘?’)[1]); var fn = params.callback; // jsonp返回设置 res.writeHead(200, { 'Content-Type': 'text/javascript' }); res.write(fn + '(' + JSON.stringify(params) + ')'); res.end(); }); server.listen(‘8080’);console.log(‘Server is running at port 8080…’);jsonp缺点：只能实现get一种请求。 二、 document.domain + iframe跨域此方案仅限主域相同，子域不同的跨域应用场景。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 1.）父窗口：(http://www.domain.com/a.html) document.domain = ‘domain.com’; var user = ‘admin’;2.）子窗口：(http://child.domain.com/b.html) document.domain = ‘domain.com’; // 获取父窗口中变量 alert(‘get js data from parent —&gt; ‘ + window.parent.user);三、 location.hash + iframe跨域实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。 1.）a.html：(http://www.domain1.com/a.html) var iframe = document.getElementById(‘iframe’); // 向b.html传hash值 setTimeout(function() { iframe.src = iframe.src + &apos;#user=admin&apos;; }, 1000); // 开放给同域c.html的回调方法 function onCallback(res) { alert(&apos;data from c.html ---&gt; &apos; + res); } 2.）b.html：(http://www.domain2.com/b.html) var iframe = document.getElementById(‘iframe’); // 监听a.html传来的hash值，再传给c.html window.onhashchange = function () { iframe.src = iframe.src + location.hash; }; 3.）c.html：(http://www.domain1.com/c.html) // 监听b.html传来的hash值 window.onhashchange = function () { // 再通过操作同域a.html的js回调，将结果传回 window.parent.parent.onCallback(‘hello: ‘ + location.hash.replace(‘#user=’, ‘’)); };四、 window.name + iframe跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 1.）a.html：(http://www.domain1.com/a.html) var proxy = function(url, callback) { var state = 0; var iframe = document.createElement(‘iframe’); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() { if (state === 1) { // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); } else if (state === 0) { // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = 'http://www.domain1.com/proxy.html'; state = 1; } }; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() { iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); } }; // 请求跨域b页面数据proxy(‘http://www.domain2.com/b.html', function(data){ alert(data);});2.）proxy.html：(http://www.domain1.com/proxy....中间代理页，与a.html同域，内容为空即可。 3.）b.html：(http://www.domain2.com/b.html) window.name = ‘This is domain2 data!’;总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 五、 postMessage跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：a.） 页面和其打开的新窗口的数据传递b.） 多窗口之间消息传递c.） 页面与嵌套的iframe消息传递d.） 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 1.）a.html：(http://www.domain1.com/a.html) var iframe = document.getElementById(‘iframe’); iframe.onload = function() { var data = { name: ‘aym’ }; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), ‘http://www.domain2.com'); }; // 接受domain2返回数据 window.addEventListener(&apos;message&apos;, function(e) { alert(&apos;data from domain2 ---&gt; &apos; + e.data); }, false); 2.）b.html：(http://www.domain2.com/b.html) // 接收domain1的数据 window.addEventListener(‘message’, function(e) { alert(‘data from domain1 —&gt; ‘ + e.data); var data = JSON.parse(e.data); if (data) { data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), &apos;http://www.domain1.com&apos;); } }, false); 六、 跨域资源共享（CORS）普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。 需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。 目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。 1、 前端设置：1.）原生ajax // 前端设置是否带cookiexhr.withCredentials = true;示例代码： var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容 // 前端设置是否带cookiexhr.withCredentials = true; xhr.open(‘post’, ‘http://www.domain2.com:8080/login', true);xhr.setRequestHeader(‘Content-Type’, ‘application/x-www-form-urlencoded’);xhr.send(‘user=admin’); xhr.onreadystatechange = function() { if (xhr.readyState == 4 && xhr.status == 200) { alert(xhr.responseText); }};2.）jQuery ajax $.ajax({ … xhrFields: { withCredentials: true // 前端设置是否带cookie }, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie …});3.）vue框架 a.) axios设置： axios.defaults.withCredentials = trueb.) vue-resource设置： Vue.http.options.credentials = true2、 服务端设置：若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。 1.）Java后台： /* 导入包：import javax.servlet.http.HttpServletResponse; 接口参数中定义：HttpServletResponse response*/ // 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加’/‘response.setHeader(“Access-Control-Allow-Origin”, “","link":"/2020/02/18/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"Markdown Nice使用教程","text":"1 Markdown Nice 简介支持自定义样式的 Markdown 编辑器支持微信公众号、知乎和稀土掘金2 主题「https://product.mdnice.com/themes/」欢迎提交主题，提供更多文章示例~~3 通用语法3.1 标题在文字写书写不同数量的#可以完成不同的标题，如下：一级标题二级标题三级标题3.2 无序列表无序列表的使用，在符号-后加空格使用。如下：无序列表 1无序列表 2无序列表 3如果要控制列表的层级，则需要在符号-前使用空格。如下：无序列表 1无序列表 2无序列表 2.1无序列表 2.2「由于微信原因，最多支持到二级列表」。3.3 有序列表有序列表的使用，在数字及符号.后加空格后输入内容，如下：有序列表 1有序列表 2有序列表 33.4 粗体和斜体粗体的使用是在需要加粗的文字前后各加两个。而斜体的使用则是在需要斜体的文字前后各加一个。如果要使用粗体和斜体，那么就是在需要操作的文字前后加三个*。如下：「这个是粗体」这个是斜体「这个是粗体加斜体」注：由于 commonmark 标准，可能会导致加粗与想象不一致，如下今天天气好晴朗，处处好风光。这个是正常现象，请参考加粗 Issue[1]。3.5 链接微信公众号仅支持公众号文章链接，即域名为https://mp.weixin.qq.com/的合法链接。使用方法如下所示：对于该论述，欢迎读者查阅之前发过的文章，你是《未来世界的幸存者》么？3.6 引用引用的格式是在符号 > 后面书写文字，文字的内容可以包含标题、链接、图片、粗体和斜体等。一级引用如下：❝一级引用示例读一本好书，就是在和高尚的人谈话。 「——歌德」❞当使用多个 > 符号时，就会变成多级引用二级引用如下：二级引用示例读一本好书，就是在和高尚的人谈话。 「——歌德」Markdown Nice最全功能介绍三级引用如下：三级引用示例读一本好书，就是在和高尚的人谈话。 「——歌德」Markdown Nice最全功能介绍3.7 分割线可以在一行中用三个以上的减号来建立一个分隔线，同时需要在分隔线的上面空一行。如下：3.8 删除线删除线的使用，在需要删除的文字前后各使用两个~，如下：这是要被删除的内容。3.9 表格可以使用冒号来定义表格的对齐方式，如下：姓名年龄工作小可爱18吃可爱多小小勇敢20爬棵勇敢树小小小机智22看一本机智书宽度过长的表格可以滚动，可在自定义主题中调节宽度：姓名年龄工作邮箱手机小可爱18吃可爱多lovely@test.com18812345678小小勇敢20爬棵勇敢树brave@test.com17712345678小小小机智22看一本机智书smart@test.com166123456783.10 图片插入图片，如果是行内图片则无图例，否则有图例，格式如下：这里写图片描述可以通过在图片尾部添加宽度和高度控制图片大小，用法如下：同时设置宽度和高度只设置宽度，推荐使用百分比该语法比较特殊，其他 Markdown 编辑器不完全通用。支持 jpg、png、gif、svg 等图片格式，「其中 svg 文件仅可在微信公众平台中使用」，svg 文件示例如下：支持图片「拖拽和截图粘贴」到编辑器中上传，上传时使用当前选择的图床。可使用「格式->图片」上传本地图片，网站目前支持「图壳」图床，失败率低，但是只可保存一天用于排版「注：仅支持 https 的图片，图片粘贴到微信、知乎或掘金时会自动上传其服务器，不必担心使用上述图床会导致图片丢失」。图片还可以和链接嵌套使用，能够实现推荐卡片的效果，用法如下：Markdown Nice 最全功能介绍4. 特殊语法4.1 脚注❝支持平台：微信公众号、知乎。❞脚注与链接的区别如下所示：链接：文字脚注：文字有人认为在大前端时代[2]的背景下，移动端开发（Android、IOS）将逐步退出历史舞台。全栈工程师[3]在业务开发流程中起到了至关重要的作用。脚注内容请拉到最下面观看。4.2 代码块❝支持平台：微信公众号、知乎。❞如果在一个行内需要引用代码，只要用反引号引起来就好，如下：Use the printf() function.在需要高亮的代码块的前一行及后一行使用三个反引号，同时「第一行反引号后面表示代码块所使用的语言」，如下：// FileName: HelloWorld.javapublic class HelloWorld { // Java 入口程序，程序从此入口 public static void main(String[] args) { System.out.println(“Hello,World!”); // 向控制台打印一条语句 }}支持以下语言种类：bashclojure，cpp，cs，cssdart，dockerfile, differlanggo，gradle，groovyhaskelljava，javascript，json，juliakotlinlisp，luamakefile，markdown，matlabobjectivecperl，php，pythonr，ruby，rustscala，shell，sql，swifttex，typescriptverilog，vhdlxmlyaml如果想要更换代码主题，可在上方挑选，不支持代码主题自定义。其中「微信代码主题与微信官方一致」，有以下注意事项：带行号且不换行，代码大小与官方一致需要在代码块处标志语言，否则无法高亮粘贴到公众号后，用鼠标点代码块内外一次，完成高亮diff 不能同时和其他语言的高亮同时显示，且需要调整代码主题为微信代码主题以外的代码主题才能看到 diff 效果，使用效果如下:+ 新增项- 删除项「其他主题不带行号，可自定义是否换行，代码大小与当前编辑器一致」4.3 数学公式❝支持平台：微信公众号、知乎。❞行内公式使用方法，比如这个化学公式：块公式使用方法如下：矩阵：公式由于微信不支持，目前的解决方案是转成 svg 放到微信中，无需调整，矢量不失真。目前测试如果公式量过大，在 Chrome 下会存在粘贴后无响应，但是在 Firefox 中始终能够成功。4.4 TOC❝支持平台：微信公众号、知乎。❞TOC 全称为 Table of Content，列出全部标题。由于示例标题过多，需要使用将下方代码段去除即可。[TOC]由于微信只支持到二级列表，本工具仅支持二级标题和三级标题的显示。4.5 注音符号❝支持平台：微信公众号。❞支持注音符号，用法如下：Markdown Nice 这么好用，简直是喜大普奔hē hē hē hē呀！4.6 横屏滑动幻灯片❝支持平台：微信公众号。❞通过这种语法设置横屏滑动滑动片，具体用法如下：< 左右滑动见更多 >>>","link":"/2020/11/09/MD%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"VUE","slug":"VUE","link":"/tags/VUE/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"跨域","slug":"跨域","link":"/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"md","slug":"md","link":"/tags/md/"}],"categories":[]}