{"pages":[],"posts":[{"title":"一像素","text":"产生原因由于分辨率 DPI 的差异，高清手机屏上的 1px 实际上是由 2×2 个像素点来渲染，有的屏幕甚至用到了 3×3 个像素点所以 border: 1px 在移动端会渲染为 2px 的边框解决方案一 (不推荐) 使用高度为 1px 的图片代替 1234.border-bottom-1px { border-width: 0 0 1px 0; border-image: url(1px.png) 0 0 2 0 stretch;} 解决方案二通过 js 获取到设备像素比，然后动态添加 标签 ，控制缩放 123456789101112(function() { var scale = 1.0; if (window.devicePixelRatio === 2) { scale *= 0.5; } if (window.devicePixelRatio === 3) { scale *= 0.333333; } var text = '&lt;meta name=\"viewport\" content=\"initial-scale=' + scale + ', maximum-scale=' + scale +', minimum-scale=' + scale + ', width=device-width, user-scalable=no\" /&gt;'; document.write(text); })(); 解决方案三 (推荐)使用伪类 :after 创建 1px 的边框，后通过 媒体查询（media） 适配不同的设备像素比 123456789101112131415161718192021222324252627282930313233.border-bottom-1px { position: relative;}.border-bottom-1px::after { content: ' '; position: absolute; left: 0; bottom: 0; width: 100%; height: 1px; background-color: #222;}/* 1.5倍屏 */@media only screen and (-webkit-min-device-pixel-ratio: 1.5) { .border-bottom::after { -webkit-transform: scaleY(0.7); transform: scaleY(0.7); }}/* 2倍屏 */@media only screen and (-webkit-min-device-pixel-ratio: 2) { .border-bottom::after { -webkit-transform: scaleY(0.5); transform: scaleY(0.5); }}/* 3倍屏 */@media only screen and (-webkit-min-device-pixel-ratio: 3) { .border-bottom::after { -webkit-transform: scaleY(0.33); transform: scaleY(0.33); }}","link":"/2019/01/10/01.一像素/"},{"title":"axios","text":"axios 1234567891011121314axios({ method: 'post', url: 'xxxxxx', data: { a: 'data1', b: 'data2' }}) .then(function(response) { console.log(response) //请求成功 }) .catch(function(error) { console.log(error) //请求失败 }) 执行 GET 请求12345678910111213// 为给定 ID 的 user 创建请求axios .get('/user', { params: { ID: 12345 } }) .then(function(response) { console.log(response) }) .catch(function(error) { console.log(error) }) 1234567891011### 执行 POST 请求axios.post('/user', { ID: '1234'}).then(function (response) { console.log(response);}).catch(function (error) { console.log(error);});","link":"/2019/01/17/03.axios/"},{"title":"如何聊天","text":"聊天顾名思义就是为了交换彼此的信息，更确切来说是交换两性之间各自的高价值信息，以此来打开话题，从来都不是一个人的单口相声。 【聊天思维】 男女的思维模式是不一样的，90%以上的两性沟通障碍，基本上都是由于不同的思维模式导致的，通俗的说就是：‘同一问题，同一事件，男女用不同的角度去看待，不能产生共鸣，结果自然不一样’。 男性思维【理性】： 拘谨·刻意 把话题当问题看待，喜欢把问题抽象化，从宏观角度看问题。 同一问题，男生会思考如何定性？什么原因？解决方向？解决方法？ 男生一般不太喜欢谈及某件事的感受、事物的细节，他们一般觉得太繁琐，大脑记不住那么多，也不想记，所以男生一般喜欢谈及宏观的，格局更大的事物。 5·所以，要想与一个男生聊得开心，莫过于在他熟悉的领域，听他倾诉，他的学识、见解、造诣等（如游戏方面，打篮球方面……） 女性思维【感性】： 自由·发散·感觉 倾于表达，获得共鸣，得到认同 同一问题，女生会思考怎么发生的？得到什么感受？有什么影响？有什么想法？ 女生更细腻，更喜欢关注问题的细节和感受，以及带给她的想法、经历 所以，要想与一个女生聊得开心，莫过于同她谈及对某件事情的感受，对某个问题的想法，某个不起眼的细节等（如社会热点方面，旅游，想去的城市…… 舒适的开场白，给人良好的第一印象见到陌生人,总是可以先聊聊他(她)的名字, 中国人的名字,常常融入美好的寓意、典故 持续不断的聊天从刚才他说的话里面再找一个另一个关键词，在一句他说的话里面重复一下，就可以了，就像鹦鹉学社一样 Cold readingCold reading 直译过来称为“冷读”。女孩最讨厌查户口式的问题。你多大了？你是哪里人？你叫什么名字？很可惜大部分人依然只会这种表面的聊天模式。比如：“你是不是在国外留过学？”这是一句普通的问句。转换成冷读就是：“你一定有在国外留过学。”再比如：“你觉得自己的性格怎么样？”转换成冷读就是：“如果我没看错，你的人缘一定不错吧~”可能你已经发现了一点，那就是冷读必须用陈述句。而且，冷读是一种猜测。既然是猜测就会不确。但这并不意味着冷读就失败了。冷读并不是让你完全猜准对方的 信息，而是通过这种方式让对方敞开心扉，主动的给你更多的信息。当然你不能胡乱去猜。而是通过对方的衣着，谈吐，话题内容等等一切信息去让你的猜测更加准确。 和女生聊天怎么增加聊天的话题？跟别人聊天，没有话题，怎么办？ 眼神:自信笃定,期待乐观,别飘忽不定,东张西望.(当你看一个人时,她突然直视你,怎么 经典聊天翻车现场 以及最经典的例子女生：“我感冒了”男生：多喝热水女生：…… 喝你@#试问大家，一个女生冷了，不知道应该多穿衣服么，她感冒了，不知道多喝热水么，显然这个答案是否定的。那么，她跟你交流的目的其实是“分享感受”。而正确的聊天方式，是理解女生的感受，并延伸出更多话题还是那两个例子女生：今天好冷啊男生：可不是吗，不过今天大街上看到一个大冷天坚持美丽“冻”人的妹子穿超短裙哦，你也应该试试，你腿比她好看女生：哼，色狼，我才不会那么穿，多奇怪啊男生：我记得你去年夏天穿过一个牛仔短裙，挺好看的女生：哦，那条裙子还是我20岁生日的时候买的，现在都有点穿不上了，blablabla……女生：今天加班，好累（抱怨情绪）男生：休息日还加班，你老板太没人性了吧，虐待小动物啊女生：哼，你才小动物男生：哈哈我擅长照顾小动物了，赶紧干活儿，忙完奖励你美食哦（模糊邀约）女生：哼哼，要约本姑娘吃饭么，我考虑下男生：上周去了南锣鼓巷新开的芝士火锅店，那味道，啧啧（分享生活状态）女生：是吗我上次去南锣鼓巷去了一家xx店，blablabla…","link":"/2018/12/11/05.聊天技巧/"},{"title":"关于SPA,SEO,SSR","text":"前后端分离开发的大趋势下催生几个概念：SPA、SEO和SSR SPA(single page web application 单页Web应用)SPA是一种 网络应用程序(WebApp)模型。在传统的网站中，不同的页面之间的切换都是直接从服务器加载一整个新的页面，而在SPA这个模型中，是通过动态地重写页面的部分与用户交互，而避免了过多的数据交换，响应速度自然相对更高 特点 速度：更好的用户体验，让用户在web app感受native app的速度和流畅， MVVM：经典MVVM开发模式，前后端各负其责。 ajax：重前端，业务逻辑全部在本地操作，数据都需要通过AJAX同步、提交。 路由：在URL中采用#号来作为当前视图的地址,改变#号后的参数，页面并不会重载 目前常见的几个SPA框架 AngularJS React Vue.js SPA的优点 基本上前面所说的前后端分离的优点它都有，另外还有以下的一些优点 页面之间的切换非常快 一定程度上减少了后端服务器的压力（不用管页面逻辑和渲染） 后端程序只需要提供API，完全不用管客户端到底是Web界面还是手机等 SPA的缺点 首屏打开速度很慢，因为用户首次加载需要先下载SPA框架及应用程序的代码，然后再渲染页面。 不利于SEO SEO（Search Engine Optimization 搜索引擎优化）SEO是一种通过了解搜索引擎的运作规则（如何抓取网站页面，如何索引以及如何根据特定的关键字展现搜索结果排序等）来调整网站，以提高该网站在搜索引擎中某些关键词的搜索结果排名。 搜索引擎工作原理在搜索引擎网站，比如百度，在其后台有一个非常庞大的数据库，里面存储了海量的关键词，而每个关键词又对应着很多网址，这些网址是百度程序从茫茫的互联网上一点一点下载收集而来的，这些程序称之为“搜索引擎蜘蛛”或“网络爬虫”。这些勤劳的“蜘蛛”每天在互联网上爬行，从一个链接到另一个链接，下载其中的内容，进行分析提炼，找到其中的关键词，如果“蜘蛛”认为关键词在数据库中没有而对用户是有用的便存入数据库。反之，如果“蜘蛛”认为是垃圾信息或重复信息，就舍弃不要，继续爬行，寻找最新的、有用的信息保存起来提供用户搜索。当用户搜索时，就能检索出与关键字相关的网址显示给访客。 一个关键词对用多个网址，因此就出现了排序的问题，相应的当与关键词最吻合的网址就会排在前面了。在“蜘蛛”抓取网页内容，提炼关键词的这个过程中，就存在一个问题：“蜘蛛”能否看懂。如果网站内容是flash和js，那么它是看不懂的，会犯迷糊，即使关键字再贴切也没用。相应的，如果网站内容是它的语言，那么它便能看懂，它的语言即SEO。 1&lt;meta name=\"description\" content=\"META标签用来描述一个HTML网页文档的属性，例如作者、日期和时间、网页描述、关键词、页面刷新等。...\"&gt; 1&lt;meta name=\"keywords\" content=\"META标签 META标签作用 META标签组成 META标签属性 META标签描述设计 META标签错误 META标签标签\"&gt; 矛盾点在当前前端趋势下，SPA一般只有一个主页面，内容由js获取，不便于搜索引擎获取 SPA应用中，通常通过AJAX获取数据，而这里就难以保证我们的页面能被搜索引擎正常收录到。并且有一些搜索引擎不支持执行JS和通过AJAX获取数据，那就更不用提SEO了 SSR (Server-Side Rendering 服务器端渲染）在普通的SPA中，一般是将框架及网站页面代码发送到浏览器，然后在浏览器中生成和操作DOM（这里也是第一次访问SPA网站在同等带宽及网络延迟下比传统的在后端生成HTML发送到浏览器要更慢的主要原因），但其实也可以将SPA应用打包到服务器上，在服务器上渲染出HTML，发送到浏览器，这样的HTML页面还不具备交互能力，所以还需要与SPA框架配合，在浏览器上“混合”成可交互的应用程序。所以，只要能合理地运用SSR技术，不仅能一定程度上解决首屏慢的问题，还能获得更好的SEO SSR的优点 更快的响应时间，不用等待所有的JS都下载完成，浏览器便能显示比较完整的页面了。 更好的SSR，我们可以将SEO的关键信息直接在后台就渲染成HTML，而保证搜索引擎的爬虫都能爬取到关键数据。 SSR的缺点 相对于仅仅需要提供静态文件的服务器，SSR中使用的渲染程序自然会占用更多的CPU和内存资源 一些常用的浏览器API可能无法正常使用，比如window、docment和alert等，如果使用的话需要对运行的环境加以判断 开发调试会有一些麻烦，因为涉及了浏览器及服务器，对于SPA的一些组件的生命周期的管理会变得复杂 可能会由于某些因素导致服务器端渲染的结果与浏览器端的结果不一致。 SSR常用框架 React 的 Next Vue.js 的 Nuxt 参考 浅谈SPA、SEO、SSR 百度百科","link":"/2019/01/11/02.关于SPA,SEO,SSR/"},{"title":"rem使用","text":"项目中使用rem需要引入自动换算js 比例100：1 100px=1rem12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//自定义设计稿的宽度：designWidth//最大宽度:maxWidth//这段js的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为750，最大宽度为750，则为(750,750);(function(designWidth, maxWidth) { var doc = document, win = window, docEl = doc.documentElement, remStyle = document.createElement(\"style\"), tid; function refreshRem() { var width = docEl.getBoundingClientRect().width; maxWidth = maxWidth || 540; width&gt;maxWidth &amp;&amp; (width=maxWidth); var rem = width * 100 / designWidth; remStyle.innerHTML = 'html{font-size:' + rem + 'px;}'; } if (docEl.firstElementChild) { docEl.firstElementChild.appendChild(remStyle); } else { var wrap = doc.createElement(\"div\"); wrap.appendChild(remStyle); doc.write(wrap.innerHTML); wrap = null; } //要等 wiewport 设置好后才能执行 refreshRem，不然 refreshRem 会执行2次； refreshRem(); win.addEventListener(\"resize\", function() { clearTimeout(tid); //防止执行两次 tid = setTimeout(refreshRem, 300); }, false); win.addEventListener(\"pageshow\", function(e) { if (e.persisted) { // 浏览器后退的时候重新计算 clearTimeout(tid); tid = setTimeout(refreshRem, 300); } }, false); if (doc.readyState === \"complete\") { doc.body.style.fontSize = \"16px\"; } else { doc.addEventListener(\"DOMContentLoaded\", function(e) { doc.body.style.fontSize = \"16px\"; }, false); }})(750, 750);","link":"/2019/01/15/07.rem使用/"},{"title":"浮生六记","text":"衡量爱情的标准，从来只有一个 贾平凹说过：人，可以无知，但不可以无趣。 一本《浮生六记》让我认识了一位有趣的文人——沈复： 他，才情出众，既有文人风雅，亦有稚童心态，虽半生潦倒，依然和夫人将清贫的生活过得热气腾腾。 地上两只虫子打架，沈复聚精会神地看了半天，还琢磨人家为什么打架，难道有奸情？一只癞蛤蟆跳了过来，长舌一卷，把虫子吞进了肚子。看得入迷的沈复，被吓了一跳。等回过神，气得咬牙切齿：“好你个癞蛤蟆，坏了我看虫的雅兴！”逮到蛤蟆胖揍了一番，撵出院子，方才泄愤。 夏日里到处飞的蚊子，在他的凝视下，都幻化成端庄的白鹤，在空中翩翩起舞，他扬起一抹迷之微笑，突然灵光一闪: 没有白云，白鹤飞个什么劲？赶紧把蚊子轰到蚊帐里，搞点烟雾，蚊帐里顿时“仙气”缭绕。顾不上自己被熏得眼泪汪汪，看着蚊子冲破烟雾飞翔，他心满意足地大笑起来：“这才是白鹤飞在青云上啊！”所谓有趣——是对细小事物的全神贯注是天马行空的狂想是奋不顾身的热爱。 01有趣的人，一粥一菜都是温存沈复爱吃蒜，芸娘不吃。 日子久了，芸娘被沈复的蒜味“熏陶”得受不了，也跟着吃蒜。 如此一来，两人耳鬓厮磨时，就不会嫌弃彼此浓郁的口气了。 芸娘爱吃腐乳酱瓜，便让沈复也尝尝。 奈何腐乳闻着臭气烘烘，沈复将吃腐乳比作“狗吃屎”，芸娘气坏了： “我跟着你吃臭大蒜，你却不陪我吃腐乳，还骂我是狗。” 架不住娇妻的投诉，沈复硬着头皮“当了一回狗”。 入口后，腐乳独特的咸鲜香辣，让他如释重负，原来闻着臭的东西，吃起来的味道妙不可言。 从此，大蒜、腐乳成了二人餐桌上的美食。 芸娘的堂姐出嫁，沈复去观礼。 忙到大半夜，他饿得眼冒金星，到处找吃的。 芸娘神秘地对沈复招手，将他带到自己的闺房，变戏法一般从柜子里端出了一锅清粥，一碟小菜。 沈复两眼放光，激动坏了，就差给芸娘跪了高呼“万岁”。 当时，两人尚未成亲， 一个大男人躲在大姑娘的房里吃东西，还是低调点好。 沈复压住狂喜，挽起袖子食指大动，芸娘的脸上飞起一抹红云，笑颜如花。 沈复一生清贫，清粥咸菜是家常便饭，只要和心上人一起吃，粗茶淡饭亦可饕餮。 一粥一菜里都是温存。 02有趣的人，花草虫石，处处美好沈复爱好花草，放在现代，他就是“花痴”。 菊花盛放时，他会剪下来做插花。 每个花瓶只插一个品种，一种颜色，单数花枝。 经沈复之手完成的插花作品，或亭亭玉立，或飞舞横斜，姿态万千，错落有致。 在他卧室的床头，常年有一瓶雅致的插花，都是他的作品。 家里的锅碗瓢盆，也是沈复搞艺术创作的素材。 沈复对虫子是真爱。他的艺术作品怎能少了虫子的身影？ 他和芸娘去抓螳螂和蝴蝶，用细丝把它们栓起来绑在花草上，还不忘给虫子凹造型： 蝴蝶的翅膀要展开一点才有韵味，螳螂的双臂要高举才威武。 经沈复的用心打造，花草虫石，完美地组合在一起，精致且富有活力，让人赞不绝口。 一花一草，一石一虫，都是大自然的馈赠。 有人熟视无睹，有人视若珍宝。 有趣的人，总能懂得花草虫石，都是生活的美好。 03有趣的人，嬉笑玩闹，不拘世俗有一次，水仙庙要举行庆典。 因插花水平一流，朋友邀请沈复布置插花。 沈复想让芸娘同去，就在她跟前鼓吹： “这场夜宴，花色明艳，光影流离，吹奏笙箫，欢歌唱闹，好玩得很！” 芸娘心动，出于旧俗，顾虑女人不便去，沈复狡黠一笑： “戴我的冠，穿我的衣，化女为男，我们一起去！” 他把芸娘的发髻散开，改为辫子，将他的帽子戴在妻子头上，长衫略长不要紧，从腰间打折缝起来，外头再套个马褂，就看不出来了。 沈复又给妻子买了时髦的“蝴蝶靴”，男女都可以穿。 芸娘担心婆婆知道了会生气，沈复拍着胸脯担保： “怕什么？老太太走亲戚去了，我俩悄悄走，悄悄回，他们怎么知道？再说了，庙里管事的都是我朋友，就算识破你是女人家，还不是一笑了之？” 芸娘这才欣然前往。 有趣的人，洒脱不羁，不为世俗所阻。 芸娘守旧礼，对待丈夫十分恭敬。 沈复不在乎那么多规矩，他就喜欢拉着妻子的手，咬个耳朵，说点情话，温情地给妻子整理衣袖。 每次这么做，芸娘都拘谨地说“岂敢”，沈复逗趣她“礼多必诈”。 两口子路上遇见了，沈复就拱手作揖，说声“得罪”，芸娘心神领会，屈膝回礼来句“岂敢”。 两句敬辞，被夫妻二人玩成了口头禅。 有趣的人，之乎者也、繁文缛节也是一种雅兴和情怀。 04有趣的人，以诗下酒，印章传情红袖添香，诗酒相伴，是文人墨客的标配，沈复也不例外。 他看书写字时，芸娘就研磨沏茶。 他好喝两口小酒，芸娘虽不善饮酒，但放开怀也能喝上几杯。 为了让妻子陪自己小酌，沈复教她行酒令“射覆”，类似现代的摇骰子猜数字，两人玩得不亦乐乎，谁输了谁喝酒，以诗下酒，好不快活。 沈复还喜欢和妻子“讨论学术”，他鼓励且欣赏妻子有自己的见解和评判。 两人曾讨论过，谁才是唐诗界的扛把子。 沈复选了沉稳的杜甫，芸娘则喜欢活泼的李白。 沈复吃醋地调侃说： “想不到，我的老婆竟然是李太白的拥趸”，芸娘笑着安抚他：“你字称三白，也带个‘白’字。我的诗歌启蒙来源于白居易，再加上李太白，你们这三白，都是我崇敬的人。” 才子佳人，精神相交便不过如此了。 沈复工作不稳定，偶尔去外地给人当幕僚，夫妻两地分居的日子里，鸿雁传书就是他和芸娘互诉衷肠的方式。 沈复亲手打造了朱白两枚印章，章面写着“愿生生世世为夫妇”，他拿的是阳文，妻子拿的是阴文。 写完信，拿出印章，呵一口气，用力地盖在信笺上，整颗心也跟着印了上去。 印章都是情侣款，这种境界的秀恩爱，也是前无古人后无来者了。 有趣的人，诗词可下酒，印章能传情，生活处处有情调。 05有趣，是做人的最高配置林语堂将《浮生六记》视为知己并评价说： “读沈复的书，使我感到这安乐的奥妙，远超乎尘俗之压迫与人身之痛苦。” 很多人喜欢沈复，是被《浮生六记》中的烟火江南，闺房趣事所吸引。 他笔下妙趣横生、温情款款的片段，让大家都不由地感慨： 浮生若梦，做人还是有趣的好。 《沉默的大多数》中有句话： 我活在世上，无非想明白些道理，遇见些有趣的事。 有趣的人，才能遇见有趣的事。 感谢沈复教会我们，做个有趣之人，桃花树下，酒烫茶温；布衣菜饭，可乐终身。 不论生活贫穷还是富裕，顺境还是逆境，用心生活，把平凡无奇的日子过成精彩纷呈的段子。","link":"/2019/06/11/09.浮生六记/"},{"title":"前端面试","text":"面试准备及技巧一. 面试前简历及面试准备假如你要面试一个公司，他们主招 Vue 技术栈的前端开发，那么你的简历里面只有 Vue 这个名词是不够的，最好能体现出 Vue 的生态来。这样写就不错：熟练使用 ElementUI＋Vue＋Vuex 开发项目，Webpack 构建项目，Nuxtjs 做服务端渲染。 简历中出现的技术一定要能说出个一二三，不要一问三不知 简历堆砌技术名词其实是一把双刃剑： 不写技术名词，简历容易被刷掉； 写上的话，可是需要充分的准备哦，否则这可能成为你的软肋； 写进简历的项目一定要了如指掌 项目的前期构建， 总结项目开发中遇到的问题及解决思路 在项目中学到的经验 项目的打包上线部署 二. 面试 落落大方，面试是公司选你，也是你选公司的过程。工作可以不要，气势不能丢 准备一段自我介绍 几句个人简介，名字毕业学校，工作经验，上家公司 主要负责的工作 换工作的原因及预期 具备常用算法，数组操作，经典css布局等的手写能力 对前端技术实现原理，底层，优缺点的理解 既然你熟练使用VUE 那vue有什么优缺点 职业规划 你有什么问题想问我？ 三. 面试总结 面试千篇一律，善于总结方能立于不败之地","link":"/2019/01/16/08.前端面试/"},{"title":"vue.js中$watch的oldvalue与newValue","text":"由于vue内部机制，导致对象或数组改变时旧值将与新值相同vue.js文档中指出&nbsp;&nbsp;&nbsp;&nbsp;详情&gt;&gt; 解决方案一，this.$set 方法二，Object.assign()方法三，计算属性 computed1234567export default { data () { return { msg: &apos;Highlighted!&apos; } }}","link":"/2018/12/11/04.vue.$watch值更新问题/"},{"title":"ESlint报错解决方案","text":"Unary operator ‘++’ usedESLint 不允许++ 运算比如1234567891011for (let i = 0; i &lt; 3; i ++) { // ...}for (let i = 0; i &lt; 3; i += 1) { // ...}temp++var temp = 0;temp += 1; Missing radix parameter 缺少基数参数ESLint parseInt()方法必须传入第二参数radix1234parseInt(string, radix)parseInt('123', 0)radix 取值范围2~36代表数字基数不传或传0代表10进制 –传入0可解决parseInt(‘123’, 0) Unexpected string concatenation 意外的字符串连接不允许字符串拼接1'0' + month ======》`0${month}`; Expected to return a value in arrow function 箭头函数期望有返回值使用map时Eslint希望有返回值123columns.map(item =&gt; { item.name='xx'}); 1：用Object.keys(this.props.ntn).forEach去替换.map，因为ESLint array-callback-return这个警告是因为在使用map, filter , reduce 没有去返回一个值。 2：当然也可以使用map,在react中用jsx的方式，直接把{}改成()即可。 扩展map:和forEach非常相似，都是用来遍历数组中的每一项值的，用来遍历数组中的每一项；区别：map的回调函数中支持return返回值；return的是啥，相当于把数组中的这一项变为啥（并不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了）；不管是forEach还是map 都支持第二个参数值，第二个参数的意思是把匿名回调函数中的this进行修改。 JSX props should not use .bind() JSX语法中不能使用.bind() ERROR 1&lt;form onSubmit={handleSubmit(this.handleFormSubmit.bind(this))}&gt; SUCCESS Option 1: Use arrow functions (with babel-plugins) PS:- Experimental feature 1234567891011121314class MyComponent extends Component { handleClick = (args) =&gt; () =&gt; { // access args here; // handle the click event } render() { return ( &lt;div onClick={this.handleClick(args)}&gt; ..... &lt;/div&gt; ) }} Option 2: Not recommended Define arrow functions in render 123456789101112class MyComponent extends Component { render() { const handleClick = () =&gt; { // handle the click event } return ( &lt;div onClick={handleClick}&gt; ..... &lt;/div&gt; ) } } Option 3: Use binding in constructor 12345678910111213141516171819class MyComponent extends Component { constructor() { super(); this.handleClick = this.handleClick.bind(this); } handleClick() { // handle click } render() { return ( &lt;div onClick={this.handleClick}&gt; ..... &lt;/div&gt; ) } }","link":"/2019/06/18/10.ESlint报错解决方案/"},{"title":"VUE开发中遇到的问题","text":"对象数组深度监听 问题: 后端传过来的数组是一个数组对象，页面中绑定对象中某一具体的属性，当该值变化时调用某个函数，自然想到就是watch方法。但如何watch数组对象中某一个具体的属性，显然不可能一个个属性写watch。 解决办法： watch整个对象，设置deep为true，当该对象发生改变时，调用处理函数。 将页面中绑定的属性写在computed函数中，watch这个computed中的函数，当对象值改变时会进入computed函数中，进而进入watch函数中，再调用处理函数。 子组件生命周期执行顺序问题 本地开发跨域问题 问题: 在本地开发请求后端服务器接口的时候，都不可避免的会遇到跨域的问题。 解决方法可以通过加一个node中间层或者nginx做反向代理。 如果是用vue-cli搭建的项目，vue-cli在config中自带了一个proxyTable属性，可以配置这个属性解决跨域的问题。 父组件控制子组件样式问题使用 xx /deep/ xx 或者 xx &gt;&gt;&gt; xx 对象赋值无法双向绑定例如对象obj ={a:1},如果想要修改obj中的a属性，通过obj.a = 2这样赋值，页面不会更新，需使用vue.set方法更改才会起作用， Vue.set(this,obj,a,2); 同样，如果要给obj增加一个新属性，如果该属性未在data中声明，页面也不会刷新。也就是vue文档中声明的“Vue 不能检测到对象属性的添加或删除”，同样需要使用vue.set方法进行赋值才好使。","link":"/2019/04/15/VUE开发中遇到的问题/"},{"title":"JavaScript进阶问题列表","text":"JavaScript 进阶问题列表 摘自github 从基础到进阶，测试你有多了解 JavaScript，刷新你的知识，或者帮助你的 coding 面试！ 答案在问题下方的折叠部分，点击即可展开问题。祝你好运 1. 输出是什么？12345678function sayHi() { console.log(name) console.log(age) var name = 'Lydia' let age = 21}sayHi() A: Lydia 和 undefined B: Lydia 和 ReferenceError C: ReferenceError 和 21 D: undefined 和 ReferenceError 答案#### 答案: D在函数内部，我们首先通过 var 关键字声明了 name 变量。这意味着变量被提升了（内存空间在创建阶段就被设置好了），直到程序运行到定义变量位置之前默认值都是 undefined。因为当我们打印 name 变量时还没有执行到定义变量的位置，因此变量的值保持为 undefined。通过 let 和 const 关键字声明的变量也会提升，但是和 var 不同，它们不会被初始化。在我们声明（初始化）之前是不能访问它们的。这个行为被称之为暂时性死区。当我们试图在声明之前访问它们时，JavaScript 将会抛出一个 ReferenceError 错误。 2. 输出是什么？1234567for (var i = 0; i &lt; 3; i++) { setTimeout(() =&gt; console.log(i), 1)}for (let i = 0; i &lt; 3; i++) { setTimeout(() =&gt; console.log(i), 1)} A: 0 1 2 和 0 1 2 B: 0 1 2 和 3 3 3 C: 3 3 3 和 0 1 2 答案#### 答案: C由于 JavaScript 的事件循环，setTimeout 回调会在遍历结束后才执行。因为在第一个遍历中遍历 i 是通过 var 关键字声明的，所以这个值是全局作用域下的。在遍历过程中，我们通过一元操作符 ++ 来每次递增 i 的值。当 setTimeout 回调执行的时候，i 的值等于 3。在第二个遍历中，遍历 i 是通过 let 关键字声明的：通过 let 和 const 关键字声明的变量是拥有块级作用域（指的是任何在 {} 中的内容）。在每次的遍历过程中，i 都有一个新值，并且每个值都在循环内的作用域中。 3. 输出是什么？12345678910const shape = { radius: 10, diameter() { return this.radius * 2 }, perimeter: () =&gt; 2 * Math.PI * this.radius}shape.diameter()shape.perimeter() A: 20 and 62.83185307179586 B: 20 and NaN C: 20 and 63 D: NaN and 63 答案#### 答案: B注意 diameter 的值是一个常规函数，但是 perimeter 的值是一个箭头函数。对于箭头函数，this 关键字指向的是它当前周围作用域（简单来说是包含箭头函数的常规函数，如果没有常规函数的话就是全局对象），这个行为和常规函数不同。这意味着当我们调用 perimeter 时，this 不是指向 shape 对象，而是它的周围作用域（在例子中是 window）。在 window 中没有 radius 这个属性，因此返回 undefined。 4. 输出是什么？12;+true!'Lydia' A: 1 and false B: false and NaN C: false and false 答案#### 答案: A一元操作符加号尝试将 bool 转为 number。true 转换为 number 的话为 1，false 为 0。字符串 'Lydia' 是一个真值，真值取反那么就返回 false。 5. 哪一个是无效的？12345678const bird = { size: 'small'}const mouse = { name: 'Mickey', small: true} A: mouse.bird.size B: mouse[bird.size] C: mouse[bird[&quot;size&quot;]] D: All of them are valid 答案#### 答案: A在 JavaScript 中，所有对象的 keys 都是字符串（除非对象是 Symbol）。尽管我们可能不会定义它们为字符串，但它们在底层总会被转换为字符串。当我们使用括号语法时（[]），JavaScript 会解释（或者 unboxes）语句。它首先看到第一个开始括号 [ 并继续前进直到找到结束括号 ]。只有这样，它才会计算语句的值。mouse[bird.size]：首先计算 bird.size，这会得到 small。mouse[&quot;small&quot;] 返回 true。然后使用点语法的话，上面这一切都不会发生。mouse 没有 bird 这个 key，这也就意味着 mouse.bird 是 undefined。然后当我们使用点语法 mouse.bird.size 时，因为 mouse.bird 是 undefined，这也就变成了 undefined.size。这个行为是无效的，并且会抛出一个错误类似 Cannot read property &quot;size&quot; of undefined。 6. 输出是什么？123456let c = { greeting: 'Hey!' }let dd = cc.greeting = 'Hello'console.log(d.greeting) A: Hello B: undefined C: ReferenceError D: TypeError 答案#### 答案: A在 JavaScript 中，当设置两个对象彼此相等时，它们会通过引用进行交互。首先，变量 c 的值是一个对象。接下来，我们给 d 分配了一个和 c 对象相同的引用。因此当我们改变其中一个对象时，其实是改变了所有的对象。 7. 输出是什么？1234567let a = 3let b = new Number(3)let c = 3console.log(a == b)console.log(a === b)console.log(b === c) A: true false true B: false false true C: true false false D: false true true 答案#### 答案: Cnew Number() 是一个内建的函数构造器。虽然它看着像是一个 number，但它实际上并不是一个真实的 number：它有一堆额外的功能并且它是一个对象。当我们使用 == 操作符时，它只会检查两者是否拥有相同的值。因为它们的值都是 3，因此返回 true。然后，当我们使用 === 操作符时，两者的值以及类型都应该是相同的。new Number() 是一个对象而不是 number，因此返回 false。 8. 输出是什么？12345678910111213class Chameleon { static colorChange(newColor) { this.newColor = newColor return this.newColor } constructor({ newColor = 'green' } = {}) { this.newColor = newColor }}const freddie = new Chameleon({ newColor: 'purple' })freddie.colorChange('orange') A: orange B: purple C: green D: TypeError 答案#### 答案: DcolorChange 是一个静态方法。静态方法被设计为只能被创建它们的构造器使用（也就是 Chameleon），并且不能传递给实例。因为 freddie 是一个实例，静态方法不能被实例使用，因此抛出了 TypeError 错误。 9. 输出是什么？123let greetinggreetign = {} // Typo!console.log(greetign) A: {} B: ReferenceError: greetign is not defined C: undefined 答案#### 答案: A代码打印出了一个对象，这是因为我们在全局对象上创建了一个空对象！当我们将 greeting 写错成 greetign 时，JS 解释器实际在上浏览器中将它视为 global.greetign = {} （或者 window.greetign = {}）。为了避免这个为题，我们可以使用 `”use strict”。这能确保当你声明变量时必须赋值。 10. 当我们这么做时，会发生什么？12345function bark() { console.log('Woof!')}bark.animal = 'dog' A: Nothing, this is totally fine! B: SyntaxError. You cannot add properties to a function this way. C: undefined D: ReferenceError 答案#### 答案: A这在 JavaScript 中是可以的，因为函数是对象！（除了基本类型之外其他都是对象）函数是一个特殊的对象。你写的这个代码其实不是一个实际的函数。函数是一个拥有属性的对象，并且属性也可被调用。 11. 输出是什么？1234567891011function Person(firstName, lastName) { this.firstName = firstName; this.lastName = lastName;}const member = new Person(\"Lydia\", \"Hallie\");Person.getFullName = function () { return `${this.firstName} ${this.lastName}`;}console.log(member.getFullName()); A: TypeError B: SyntaxError C: Lydia Hallie D: undefined undefined 答案#### 答案: A你不能像常规对象那样，给构造函数添加属性。如果你想一次性给所有实例添加特性，你应该使用原型。因此本例中，使用如下方式：123Person.prototype.getFullName = function () { return `${this.firstName} ${this.lastName}`;}这才会使 member.getFullName() 起作用。为什么这么做有益的？假设我们将这个方法添加到构造函数本身里。也许不是每个 Person 实例都需要这个方法。这将浪费大量内存空间，因为它们仍然具有该属性，这将占用每个实例的内存空间。相反，如果我们只将它添加到原型中，那么它只存在于内存中的一个位置，但是所有实例都可以访问它！ 12. 输出是什么？12345678910function Person(firstName, lastName) { this.firstName = firstName this.lastName = lastName}const lydia = new Person('Lydia', 'Hallie')const sarah = Person('Sarah', 'Smith')console.log(lydia)console.log(sarah) A: Person {firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;} and undefined B: Person {firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;} and Person {firstName: &quot;Sarah&quot;, lastName: &quot;Smith&quot;} C: Person {firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;} and {} D:Person {firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;} and ReferenceError 答案#### 答案: A对于 sarah，我们没有使用 new 关键字。当使用 new 时，this 引用我们创建的空对象。当未使用 new 时，this 引用的是全局对象（global object）。我们说 this.firstName 等于 &quot;Sarah&quot;，并且 this.lastName 等于 &quot;Smith&quot;。实际上我们做的是，定义了 global.firstName = 'Sarah' 和 global.lastName = 'Smith'。而 sarah 本身是 undefined。 13. 事件传播的三个阶段是什么？ A: Target &gt; Capturing &gt; Bubbling B: Bubbling &gt; Target &gt; Capturing C: Target &gt; Bubbling &gt; Capturing D: Capturing &gt; Target &gt; Bubbling 答案#### 答案: D在捕获（capturing）阶段中，事件从祖先元素向下传播到目标元素。当事件达到目标（target）元素后，冒泡（bubbling）才开始。 14. 所有对象都有原型。 A: true B: false 答案#### 答案: B除了基本对象（base object），所有对象都有原型。基本对象可以访问一些方法和属性，比如 .tostring。这就是为什么你可以使用内置的 JavaScript 方法！所有这些方法在原型上都是可用的。虽然 JavaScript 不能直接在对象上找到这些方法，但 JavaScript 会沿着原型链找到它们，以便于你使用。 15. 输出是什么？12345function sum(a, b) { return a + b}sum(1, '2') A: NaN B: TypeError C: &quot;12&quot; D: 3 答案#### 答案: CJavaScript 是一种动态类型语言：我们不指定某些变量的类型。值可以在你不知道的情况下自动转换成另一种类型，这种类型称为隐式类型转换（implicit type coercion）。Coercion 是指将一种类型转换为另一种类型。在本例中，JavaScript 将数字 1 转换为字符串，以便函数有意义并返回一个值。在数字类型（1）和字符串类型（'2'）相加时，该数字被视为字符串。我们可以连接字符串，比如 &quot;Hello&quot; + &quot;World&quot;，这里发生的是 &quot;1&quot; + &quot;2&quot;，它返回 &quot;12&quot;。 16. 输出是什么？1234let number = 0console.log(number++)console.log(++number)console.log(number) A: 1 1 2 B: 1 2 2 C: 0 2 2 D: 0 1 2 答案#### 答案: C一元后自增运算符 ++：1. 返回值（返回 0）2. 值自增（number 现在是 1）一元前自增运算符 ++：1. 值自增（number 现在是 2）2. 返回值（返回 2）结果是 0 2 2. 17. 输出是什么？12345678910function getPersonInfo(one, two, three) { console.log(one) console.log(two) console.log(three)}const person = 'Lydia'const age = 21getPersonInfo`${person} is ${age} years old` A: &quot;Lydia&quot; 21 [&quot;&quot;, &quot; is &quot;, &quot; years old&quot;] B: [&quot;&quot;, &quot; is &quot;, &quot; years old&quot;] &quot;Lydia&quot; 21 C: &quot;Lydia&quot; [&quot;&quot;, &quot; is &quot;, &quot; years old&quot;] 21 答案#### 答案: B如果使用标记模板字面量，第一个参数的值总是包含字符串的数组。其余的参数获取的是传递的表达式的值！ 18. 输出是什么？1234567891011function checkAge(data) { if (data === { age: 18 }) { console.log('You are an adult!') } else if (data == { age: 18 }) { console.log('You are still an adult.') } else { console.log(`Hmm.. You don't have an age I guess`) }}checkAge({ age: 18 }) A: You are an adult! B: You are still an adult. C: Hmm.. You don't have an age I guess 答案#### 答案: C在测试相等性时，基本类型通过它们的值（value）进行比较，而对象通过它们的引用（reference）进行比较。JavaScript 检查对象是否具有对内存中相同位置的引用。题目中我们正在比较的两个对象不是同一个引用：作为参数传递的对象引用的内存位置，与用于判断相等的对象所引用的内存位置并不同。这也是 { age: 18 } === { age: 18 } 和 { age: 18 } == { age: 18 } 都返回 false 的原因。 19. 输出是什么？12345function getAge(...args) { console.log(typeof args)}getAge(21) A: &quot;number&quot; B: &quot;array&quot; C: &quot;object&quot; D: &quot;NaN&quot; 答案#### 答案: C扩展运算符（...args）会返回实参组成的数组。而数组是对象，因此 typeof args 返回 &quot;object&quot;。 20. 输出是什么？1234567function getAge() { 'use strict' age = 21 console.log(age)}getAge() A: 21 B: undefined C: ReferenceError D: TypeError 答案#### 答案: C使用 &quot;use strict&quot;，你可以确保不会意外地声明全局变量。我们从来没有声明变量 age，因为我们使用 &quot;use strict&quot;，它将抛出一个引用错误。如果我们不使用 &quot;use strict&quot;，它就会工作，因为属性 age 会被添加到全局对象中了。 21. 输出是什么？1const sum = eval('10*10+5') A: 105 B: &quot;105&quot; C: TypeError D: &quot;10*10+5&quot; 答案#### 答案: A代码以字符串形式传递进来，eval 对其求值。如果它是一个表达式，就像本例中那样，它对表达式求值。表达式是 10 * 10 + 5。这将返回数字 105。 22. cool_secret 可访问多长时间？1sessionStorage.setItem('cool_secret', 123) A: Forever, the data doesn’t get lost. B: When the user closes the tab. C: When the user closes the entire browser, not only the tab. D: When the user shuts off their computer. 答案#### 答案: B关闭 tab 标签页 后，sessionStorage 存储的数据才会删除。如果使用 localStorage，那么数据将永远在那里，除非调用了 localStorage.clear()。 23. 输出是什么？1234var num = 8var num = 10console.log(num) A: 8 B: 10 C: SyntaxError D: ReferenceError 答案#### 答案: B使用 var 关键字，你可以用相同的名称声明多个变量。然后变量将保存最新的值。你不能使用 let 或 const 来实现这一点，因为它们是块作用域的。 24. 输出是什么？1234567const obj = { 1: 'a', 2: 'b', 3: 'c' }const set = new Set([1, 2, 3, 4, 5])obj.hasOwnProperty('1')obj.hasOwnProperty(1)set.has('1')set.has(1) A: false true false true B: false true true true C: true true false true D: true true true true 答案#### 答案: C所有对象的键（不包括 Symbol）在底层都是字符串，即使你自己没有将其作为字符串输入。这就是为什么 obj.hasOwnProperty('1') 也返回 true。对于集合，它不是这样工作的。在我们的集合中没有 '1'：set.has('1') 返回 false。它有数字类型为 1，set.has(1) 返回 true。 25. 输出是什么？12const obj = { a: 'one', b: 'two', a: 'three' }console.log(obj) A: { a: &quot;one&quot;, b: &quot;two&quot; } B: { b: &quot;two&quot;, a: &quot;three&quot; } C: { a: &quot;three&quot;, b: &quot;two&quot; } D: SyntaxError 答案#### 答案: C如果你有两个名称相同的键，则键会被替换掉。它仍然位于第一个键出现的位置，但是值是最后出现那个键的值。 26. JavaScript 全局执行上下文为你做了两件事：全局对象和 this 关键字。 A: true B: false C: it depends 答案#### 答案: A基本执行上下文是全局执行上下文：它是代码中随处可访问的内容。 27. 输出是什么？1234for (let i = 1; i &lt; 5; i++) { if (i === 3) continue console.log(i)} A: 1 2 B: 1 2 3 C: 1 2 4 D: 1 3 4 答案#### 答案: C如果某个条件返回 true，则 continue 语句跳过本次迭代。 28. 输出是什么？1234567String.prototype.giveLydiaPizza = () =&gt; { return 'Just give Lydia pizza already!'}const name = 'Lydia'name.giveLydiaPizza() A: &quot;Just give Lydia pizza already!&quot; B: TypeError: not a function C: SyntaxError D: undefined 答案#### 答案: AString 是内置的构造函数，我们可以向它添加属性。我只是在它的原型中添加了一个方法。基本类型字符串被自动转换为字符串对象，由字符串原型函数生成。因此，所有 string(string 对象)都可以访问该方法！ 29. 输出是什么？12345678const a = {}const b = { key: 'b' }const c = { key: 'c' }a[b] = 123a[c] = 456console.log(a[b]) A: 123 B: 456 C: undefined D: ReferenceError 答案#### 答案: B对象的键被自动转换为字符串。我们试图将一个对象 b 设置为对象 a 的键，且相应的值为 123。然而，当字符串化一个对象时，它会变成 &quot;[Object object]&quot;。因此这里说的是，a[&quot;Object object&quot;] = 123。然后，我们再一次做了同样的事情，c 是另外一个对象，这里也有隐式字符串化，于是，a[&quot;Object object&quot;] = 456。然后，我们打印 a[b]，也就是 a[&quot;Object object&quot;]。之前刚设置为 456，因此返回的是 456。 30. 输出是什么？1234567const foo = () =&gt; console.log('First')const bar = () =&gt; setTimeout(() =&gt; console.log('Second'))const baz = () =&gt; console.log('Third')bar()foo()baz() A: First Second Third B: First Third Second C: Second First Third D: Second Third First 答案#### 答案: B我们有一个 setTimeout 函数，并首先调用它。然而，它是最后打印日志的。这是因为在浏览器中，我们不仅有运行时引擎，还有一个叫做 WebAPI 的东西。WebAPI 提供了 setTimeout 函数，也包含其他的，例如 DOM。将 callback 推送到 WebAPI 后，setTimeout 函数本身(但不是回调！)将从栈中弹出。现在，foo 被调用，打印 &quot;First&quot;。foo 从栈中弹出，baz 被调用. 打印 &quot;Third&quot;。WebAPI 不能随时向栈内添加内容。相反，它将回调函数推到名为 queue 的地方。这就是事件循环开始工作的地方。一个事件循环查看栈和任务队列。如果栈是空的，它接受队列上的第一个元素并将其推入栈。bar 被调用，打印 &quot;Second&quot;，然后它被栈弹出。 31. 当点击按钮时，event.target是什么？1234567&lt;div onclick=\"console.log('first div')\"&gt; &lt;div onclick=\"console.log('second div')\"&gt; &lt;button onclick=\"console.log('button')\"&gt; Click! &lt;/button&gt; &lt;/div&gt;&lt;/div&gt; A: Outer div B: Inner div C: button D: An array of all nested elements. 答案#### 答案: C导致事件的最深嵌套的元素是事件的 target。你可以通过 event.stopPropagation 来停止冒泡。 32. 当您单击该段落时，日志输出是什么？12345&lt;div onclick=\"console.log('div')\"&gt; &lt;p onclick=\"console.log('p')\"&gt; Click here! &lt;/p&gt;&lt;/div&gt; A: p div B: div p C: p D: div 答案#### 答案: A如果我们点击 p，我们会看到两个日志：p 和 div。在事件传播期间，有三个阶段：捕获、目标和冒泡。默认情况下，事件处理程序在冒泡阶段执行（除非将 useCapture 设置为 true）。它从嵌套最深的元素向外传播。 33. 输出是什么？12345678const person = { name: 'Lydia' }function sayHi(age) { console.log(`${this.name} is ${age}`)}sayHi.call(person, 21)sayHi.bind(person, 21) A: undefined is 21 Lydia is 21 B: function function C: Lydia is 21 Lydia is 21 D: Lydia is 21 function 答案#### 答案: D使用这两种方法，我们都可以传递我们希望 this 关键字引用的对象。但是，.call 是立即执行的。.bind 返回函数的副本，但带有绑定上下文！它不是立即执行的。 34. 输出是什么？12345function sayHi() { return (() =&gt; 0)()}typeof sayHi() A: &quot;object&quot; B: &quot;number&quot; C: &quot;function&quot; D: &quot;undefined&quot; 答案#### 答案: BsayHi 方法返回的是立即执行函数(IIFE)的返回值.此立即执行函数的返回值是 0， 类型是 number参考：只有7种内置类型：null，undefined，boolean，number，string，object 和 symbol。 function 不是一种类型，函数是对象，它的类型是object。 35. 下面哪些值是 falsy?1234560new Number(0);('');(' ')new Boolean(false)undefined A: 0, '', undefined B: 0, new Number(0), '', new Boolean(false), undefined C: 0, '', new Boolean(false), undefined D: All of them are falsy 答案#### 答案: A只有 6 种 falsy 值:- undefined- null- NaN- 0- '' (empty string)- falseFunction 构造函数, 比如 new Number 和 new Boolean，是 truthy。 36. 输出是什么？1console.log(typeof typeof 1) A: &quot;number&quot; B: &quot;string&quot; C: &quot;object&quot; D: &quot;undefined&quot; 答案#### 答案: Btypeof 1 返回 &quot;number&quot;。typeof &quot;number&quot; 返回 &quot;string&quot;。 37. 输出是什么？123const numbers = [1, 2, 3]numbers[10] = 11console.log(numbers) A: [1, 2, 3, 7 x null, 11] B: [1, 2, 3, 11] C: [1, 2, 3, 7 x empty, 11] D: SyntaxError 答案#### 答案: C当你为数组设置超过数组长度的值的时候， JavaScript 会创建名为 “empty slots” 的东西。它们的值实际上是 undefined。你会看到以下场景：[1, 2, 3, 7 x empty, 11]这取决于你的运行环境（每个浏览器，以及 node 环境，都有可能不同） 38. 输出是什么？1234567891011;(() =&gt; { let x, y try { throw new Error() } catch (x) { ;(x = 1), (y = 2) console.log(x) } console.log(x) console.log(y)})() A: 1 undefined 2 B: undefined undefined undefined C: 1 1 2 D: 1 undefined undefined 答案#### 答案: Acatch 代码块接收参数 x。当我们传递参数时，这与之前定义的变量 x 不同 。这个 x 是属于 catch 块级作用域的。然后，我们将块级作用域中的变量赋值为 1，同时也设置了变量 y 的值。现在，我们打印块级作用域中的变量 x，值为 1。catch 块之外的变量 x 的值仍为 undefined， y 的值为 2。当我们在 catch 块之外执行 console.log(x) 时，返回 undefined，y 返回 2。 39. JavaScript 中的一切都是？ A: primitive or object B: function or object C: trick question! only objects D: number or object-答案 答案: AJavaScript 只有基本类型和对象。 基本类型包括 boolean, null, undefined, bigint, number, string, symbol。 40. 输出是什么？123456;[[0, 1], [2, 3]].reduce( (acc, cur) =&gt; { return acc.concat(cur) }, [1, 2]) A: [0, 1, 2, 3, 1, 2] B: [6, 1, 2] C: [1, 2, 0, 1, 2, 3] D: [1, 2, 6] 答案#### 答案: C[1, 2]是初始值。初始值将会作为首次调用时第一个参数 acc 的值。在第一次执行时， acc 的值是 [1, 2]， cur 的值是 [0, 1]。合并它们，结果为 [1, 2, 0, 1]。第二次执行， acc 的值是 [1, 2, 0, 1]， cur 的值是 [2, 3]。合并它们，最终结果为 [1, 2, 0, 1, 2, 3] 41. 输出是什么？123!!null!!''!!1 A: false true false B: false false true C: false true true D: true true false 答案#### 答案: Bnull 是 falsy。 !null 的值是 true。 !true 的值是 false。&quot;&quot; 是 falsy。 !&quot;&quot; 的值是 true。 !true 的值是 false。1 是 truthy。 !1 的值是 false。 !false 的值是 true。 42. setInterval 方法的返回值是什么？1setInterval(() =&gt; console.log('Hi'), 1000) A: a unique id B: the amount of milliseconds specified C: the passed function D: undefined 答案#### 答案: AsetInterval 返回一个唯一的 id。此 id 可被用于 clearInterval 函数来取消定时。 43. 输出是什么？1;[...'Lydia'] A: [&quot;L&quot;, &quot;y&quot;, &quot;d&quot;, &quot;i&quot;, &quot;a&quot;] B: [&quot;Lydia&quot;] C: [[], &quot;Lydia&quot;] D: [[&quot;L&quot;, &quot;y&quot;, &quot;d&quot;, &quot;i&quot;, &quot;a&quot;]] 答案#### 答案: Astring 类型是可迭代的。扩展运算符将迭代的每个字符映射成一个元素。","link":"/2019/06/19/11.JavaScript进阶问题列表/"},{"title":"VUE知识点梳理","text":"1.对于MVVM的理解 MVVM 是 Model-View-ViewModel 的缩写 Model: 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为 View: 用户操作界面。当ViewModel对Model进行更新的时候，会通过数据绑定更新到View ViewModel： 业务逻辑层，View需要什么数据，ViewModel要提供这个数据；View有某些操作，ViewModel就要响应这些操作，所以可以说它是Model for View.总结： MVVM模式简化了界面与业务的依赖，解决了数据频繁更新 MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。 MVVM的缺点1.Bug很难被调试: 因为使用双向绑定的模式，当你看到界面异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。2.一个大的模块中model也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就造成了花费更多的内存3.对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高 2.VUE生命周期 beforeCreate （创建前）vue实例的挂载元素$el和数据对象 data都是undefined, 还未初始化 created (创建后) 完成了 data数据初始化, el还未初始化 beforeMount (载入前) vue实例的$el和data都初始化了, 相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。 mounted (载入后) 在el 被新创建的 vm.$el替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互 beforeUpdate (更新前) 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。 updated （更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 beforeDestroy (销毁前） 在实例销毁之前调用。实例仍然完全可用。 destroyed (销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 3.Vue实现数据双向绑定的原理 vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调 缺陷 Object.defineProperty 无法监听数组变化，通过劫持push()pop() shift() unshift() splice() sort() reverse() Object.defineProperty 只能劫持对象的属性,因此需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历 Proxy可以直接监听数组的变化 Proxy可以直接监听对象而非属性 4.vue-router 路由守卫 全局守卫 router.beforeEach 全局前置守卫 进入路由之前 router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用 router.afterEach 全局后置钩子 进入路由之后 路由独享守卫 路由定义是设置 123456789101112const router = new VueRouter({ routes: [ { path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; { // 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖 // ... } } ] }) 路由组件内的守卫 beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 this，组件实例还没被创建 beforeRouteUpdate (2.2) 路由复用同一个组件时, 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 this beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this Vue的路由实现：hash模式 和 history模式 hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取； 特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。 hash 模式下，仅 hash 符号之前的内容会被包含在请求中，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。 history模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。 history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。 后端如果缺少对 /items/id 的路由处理，将返回 404 错误。 Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源： 如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。 组件之间的传值通信 1. 父组件给子组件传值 使用props，父组件可以使用props向子组件传递数据 1234567891011// parent&lt;child :msg=\"message\"&gt;&lt;/child&gt;// childexport default { props: { msg: { type: String, required: true } }} 2. 子组件向父组件通信123456789101112131415161718// 父组件vue模板&lt;template&gt; &lt;child @msgFunc=\"func\"&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;import child from './child.vue';export default { components: { child }, methods: { func (msg) { console.log(msg); } }}&lt;/script&gt; 123456789101112131415161718192021// 子组件vue模板&lt;template&gt; &lt;button @click=\"handleClick\"&gt;点我&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default { props: { msg: { type: String, required: true } }, methods () { handleClick () { //........ this.$emit('msgFunc'); } }}&lt;/script&gt; 3. 非父子, 兄弟组件之间通信 使用Bus 或 vuex VUEX Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。有 5 种，分别是 state、getter、mutation、action、modulevuex 的 store 是什么？vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 datastate 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性vuex 的 getter 是什么？getter 可以对 state 进行计算操作，它就是 store 的计算属性虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用如果一个状态只在一个组件内使用，是可以不用 gettersvuex 的 mutation 是什么？更改Vuex的store中的状态的唯一方法是提交mutationvuex 的 action 是什么？action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态action 可以包含任意异步操作vue 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 action 中vuex 的 module 是什么？面对复杂的应用程序，当管理的状态比较多时；我们需要将vuex的store对象分割成模块(modules)。 父子组件加载顺序12// 加载渲染过程&gt;父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted 12// 父组件更新过程 父beforeUpdate-&gt;父updated 12// 子组件更新过程父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated 12// 销毁过程父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed","link":"/2019/12/09/VUE知识梳理/"},{"title":"MarkDown教程","text":"Markdown 是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown 兼容html语言 基础语法一、标题123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 二、字体1234**这是加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~ 这是加粗的文字这是倾斜的文字这是斜体加粗的文字这是加删除线的文字 三、引用1&gt; 引用的内容 这段文字是引用的内容… 四、分割线1234-------******** ***，— 三个以上，效果相同 五、超链接，图片123超链接: [文字](url)图片:[文字](url)图片超链接: ![[百度 https://www.baidu.com](https://www.baidu.com)](https://img-bss.csdn.net/201901101629501036.png) 超链接示例百度 https://www.baidu.com 图片示例 六、列表1. 无序列表1234- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 列表内容 列表内容 列表内容 2. 有序列表12341. 列表内容2. 列表内容3. 列表内容25. 列表内容 列表内容 列表内容 列表内容 列表内容 七. 表格1234表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容 表头 表头 表头 表头 表头 表头 内容 内容 内容 内容 内容 内容 内容 内容 内容 内容 内容 内容 八. 代码高亮1单行代码 `代码内容` 单行代码 console.log('') 1234567891011getUserInfo () { this.Post({ url: this.apiNames['获取用户信息'], data: {}, success: (data) =&gt; { if (data.responseStatus.resultCode === 0) { this.userInfo = data.userInfo } } })}","link":"/2018/12/20/06.MarkDown教程/"}],"tags":[{"name":"社交","slug":"社交","link":"/tags/社交/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"VUE","slug":"VUE","link":"/tags/VUE/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"教程","slug":"教程","link":"/tags/教程/"}],"categories":[]}